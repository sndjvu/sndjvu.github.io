<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>DjVu Reference</title>
<style>
#about { margin: 0 auto; max-width: 65%; border: 1px solid black; font-size: larger; padding: 1rem; background-color: pink; }
a.bare, .filename { font-family: sans-serif; }
.hex, .ck { font-family: monospace; }
table.hoist td:nth-child(1) { vertical-align: top; }
</style>
</head>
<body>
<div id="about">
This is an unofficial transcription, with minor orthographic and stylistic changes, of the <a href="./DjVu3Spec.djvu">Celartem/Lizardtech DjVu Reference, version 3</a>. Official information about DjVu is available at <a class="bare" href="http://djvu.sourceforge.net">djvu.sourceforge.net</a>.
</div>

<h1>DjVu Reference</h1>

<table>
<tr><td>Document Date:</td><td>November 2005</td></tr>
<tr><td>From:</td><td>Lizardtech, a Celartem Company</td></tr>
<tr><td>Status of Standard:</td><td>Released</td></tr>
</table>

<section id="1">
<h2><a href="#1">1</a> Introduction</h2>
<p>Although the Internet has given us a worldwide infrastructure on which to build the universal library, much of the world’s knowledge, history, and literature is still trapped on paper in the basements of the world’s traditional libraries. Many libraries and content owners are in the process of digitizing their collections. While many such efforts involve the painstaking process of converting paper documents to computer-friendly form, such as SGML-based formats, the high cost of such conversions limits their extent. Scanning documents and distributing the resulting images electronically is not only considerably cheaper, but also more faithful to the original document because it preserves its visual aspect.</p>
<p>Despite the quickly-improving speed of network connections and computers, the number of scanned document images accessible on the Web today is relatively small. There are several reasons for this.</p>
<p>The first reason is the relatively high cost of scanning anything else but unbound sheets in black and white. This problem is slowly going away with the appearance of fast and low-cost color scanners with sheet feeders.</p>
<p>The second reason is that long-established image compression standards and file formats have proved inadequate for distributing scanned documents at high resolution, particularly color documents. Not only are the file sizes and download times impractical, the decoding and rendering times are also prohibitive. A typical magazine page scanned in color at 100 dpi in JPEG would typically occupy 100 KB to 200 KB, but the text would be hardly readable: insufficient for screen viewing and totally unacceptable for printing. The same page at 300 dpi would have sufficient quality for viewing and printing, but the file size would be 300 KB to 1000 KB at best, which is impractical for remote access. Another major problem is that a fully-decoded 300 dpi color image of a letter-size page occupies 24 MB of memory and easily causes disk swapping.</p>
<p>The third reason is that digital documents are more than just a collection of individual page images. Pages in a scanned document have a natural serial order. Special provision must be made to ensure that flipping pages be instantaneous and effortless so as to maintain a good user experience. Even more important, most existing document formats force users to download the entire document first before displaying a chosen page. However, users often want to jump to individual pages of the document without waiting for the entire document to download. Efficient browsing requires efficient random page access, fast sequential page flipping, and quick rendering. This can be achieved with a combination of advanced compression, pre-fetching, pre-decoding, caching, and progressive rendering. DjVu decomposes each page into multiple components (text, backgrounds, images, libraries of common shapes…) that may be shared by several pages and downloaded on demand. This allows a suitably designed DjVu-viewing application to handle on-demand downloading, pre-fetching, decoding, caching, and progressive rendering of the page images.</p>
</section><!-- 1 -->

<section id="2">
<h2><a href="#2">2</a> Document organization</h2>
<p>This document describes the DjVu file format. It is written “from top down”, providing first a high-level understanding of the features and techniques used in DjVu (see §<a href="#3">3</a>), then a mid-level view at the IFF85 level (see §<a href="#7">7</a>), and finally a very detailed description of the underlying algorithms and byte-by-byte makeup of DjVu files (see §<a href="#8">8</a>).</p>
</section><!-- 2 -->

<section id="3">
<h2><a href="#3">3</a> Overview</h2>
<p>This section describes the DjVu file format at a high level: how DjVu uses the Mixed Raster Content model, how images are composed into documents, and the non-raster data that such documents can also contain.

<section id="3.1">
<h3><a href="#3.1">3.1</a> DjVu images</h3>
<p>The principal imaging model used in DjVu is the “Mixed Raster Content” (MRC) model described in <a href="https://www.itu.int/rec/T-REC-T.44-200501-I/en">ITU-T Recommendation T.44</a>, <a href="https://www.iso.org/standard/32228.html">ISO/IEC 16485</a>. In this model, an image is decomposed into foreground and background layers. To select whether a particular pixel comes from the foreground or background, a bitonal “selection” or “mask” layer is provided. These three layers are compressed separately using techniques which are optimized for each type of data.</p>
<p>The foreground and background layers are compressed using a wavelet-based continuous-tone image compression technique known as “IW44”.</p>
<p>The mask layer is compressed using a bitonal image compression technique that takes advantage of repetitions of nearly identical shapes on the page (such as characters) to efficiently compress text images.</p>
<p>A DjVu image need not contain all three layers and alternative compression techniques are available for each layer.</p>
</section><!-- 3.1 -->

<section id="3.2">
<h3><a href="#3.2">3.2</a> DjVu documents</h3>
<p>DjVu documents can be single- or multi-page. Each page consists of a DjVu image as described above (photo, bitonal, or an MRC-based composition). Such a page, by itself, is a valid DjVu document. Multi-page documents can take either of two forms: bundled or indirect.</p>

<section id="3.2.1">
<h4>3.2.1 Bundled multi-page documents</h4>
<p>A bundled multi-page DjVu document uses a single file to represent the entire document. This single file contains all the pages as well as ancillary information (e.g.&nbsp;the page directory, data shared by several pages, thumbnails, etc.). Using a single-file format is very convenient for storing documents or for sending email attachments.</p>
</section><!-- 3.2.1 -->

<section id="3.2.2">
<h4>3.2.2 Indirect multi-page documents</h4>
<p>There are problems inherent to storing multiple pages in a single file. A viewer may not be able to utilize a byte-serving mechanism such as that available in HTTP/1.1. Therefore any request for any page of such a file will necessarily result in the entire document being transmitted. Furthermore, a reasonable work pattern is to read the first few pages (perhaps a table of contents) and then navigate to a page much further into the document. However, in such a file, data for page 100 can not be viewed until after data for pages 1–99 have been downloaded.</p>
<p>Indirect multi-page documents address these problems. Such a document is composed of several files. The main file is named the index file. You can view document using the URL of the index file, just like you do with a bundled multi-page document. However, the index file is very small. It simply contains the document directory and the URLs of secondary files containing the page data. When you view an indirect multi-page document, the viewer only needs to download the files corresponding to the pages you are viewing.</p>
</section><!-- 3.2.2 -->
</section><!-- 3.2 -->

<section id="3.3">
<h3><a href="#3.3">3.3</a> Non-raster data</h3>

<section id="3.3.1">
<h4>3.3.1 Annotations</h4>
<p>Every DjVu image optionally includes several different kinds of annotations. These annotations are often used to define hyperlinks to other document pages or to arbitrary Web pages. They can also be used for other purposes such as setting the initial viewing mode of a page and defining highlighted zones.</p>
</section><!-- 3.3.1 -->

<section id="3.3.2">
<h4>3.3.2 Hidden text</h4>
<p>Every DjVu image optionally includes a hidden text layer that associates graphical features with the corresponding text. The hidden text layer is usually generated by running optical character recognition software. This textual information provides for indexing DjVu documents and copying/pasting text from DjVu page images.</p>
</section><!-- 3.3.2 -->

<section id="3.3.3">
<h4>3.3.3 Thumbnails</h4>
<p>DjVu documents sometimes contain pre-computed page thumbnails. These allow a viewer to display a graphical representation of many pages by downloading a very small “thumbnail” file instead of the actual pages themselves.</p>
</section><!-- 3.3.3 -->
</section><!-- 3.3 -->
</section><!-- 3 -->

<section id="4">
<h2><a href="#4">4</a> What’s new in the DjVu file format</h2>
<p>Since the last update to the file format documentation, <a href="#6.1">Reference 1</a>, the file format has been extended to include:</p>
<dl>

<dt>Multi-page formats</dt>
<dd>DjVu documents can span more than one page. There are two multi-page formats available: bundled (single file) and indirect (separate file for each page). See §<a href="#3.2">3.2</a> and §<a href="#7.2">7.2</a>.</dd>

<dt>Annotations</dt>
<dd>Both initial viewing parameters (background color, initial zoom) and overlayed annotations (hyperlinks, text boxes) can be specified either at the document level (“shared”) or at the page level. See §<a href="#8.3.4">8.3.4</a>.</dd>

<dt>Hidden text</dt>
<dd>Text and the associated layout information can be stored with each image. This allows documents to be searched and indexed. See §<a href="#8.3.5">8.3.5</a>.</dd>

<dt>Document outline</dt>
<dd>A hierarchical outline can be specified at the document level. This allows the document to present an integrated outline for overview and navigation. See §<a href="#8.3.2">8.3.2</a>.</dd>

<dt>Colorized JB2</dt>
<dd>A palettized extension is provided for the bitonal encoder. See §<a href="#8.3.10">8.3.10</a>.</dd>

</dl>
</section><!-- 4 -->

<section id="5">
<h2><a href="#5">5</a> Acknowledgements</h2>
<p>This work is significantly based on <a href="#6.1">Reference 1</a> and the summary of file format changes described in the DjVuLibre project maintained by Leon Bottou and others.</p>
</section><!-- 5 -->

<section id="6">
<h2><a href="#6">6</a> References</h2>

<section id="6.1">
<h3><a href="#6.1">6.1</a> DjVu 2</h3>
<p>The DjVu file format specification that was originally released by AT&amp;T in 1999. <a class="bare" href="http://djvuzone.org/djvu/djvu/djvuspec/001.djvu">http://djvuzone.org/djvu/djvu/djvuspec/001.djvu</a></p>
</section><!-- 6.1 -->

<section id="6.2">
<h3><a href="#6.2">6.2</a> IFF</h3>
<p>EA IFF 85 format, Electronic Arts’ public-domain IFF standard for an Interchange File Format, released in January, 1985. <a class="bare" href="http://www.dcs.ed.ac.uk/home/mxr/gfx/2d/IFF.txt">http://www.dcs.ed.ac.uk/home/mxr/gfx/2d/IFF.txt</a></p>
</section><!-- 6.2 -->

<section id="6.3">
<h3><a href="#6.3">6.3</a> JPEG</h3>
<p>JPEG File Interchange Format, Version 1.01 (ISO DIS 10918-1, JPEG JFIF). The specification is located at <a class="bare" href="http://www.w3.org/Graphics/JPEG/jfif.txt">http://www.w3.org/Graphics/JPEG/jfif.txt</a>.</p>
</section><!-- 6.3 -->

<section id="6.4">
<h3><a href="#6.4">6.4</a> TIFF</h3>
<p><a class="bare" href="http://partners.adobe.com/public/developer/en/tiff/TIFF6.pdf">http://partners.adobe.com/public/developer/en/tiff/TIFF6.pdf</a></p>
</section><!-- 6.4 -->

<section id="6.5">
<h3><a href="#6.5">6.5</a> G4</h3>
<p>ITU-T (CCITT) T.6. Facsimile Coding Schemes and Coding Control Functions for Group 4 Facsimile Apparatus. <a class="bare" href="https://www.itu.int/rec/T-REC-T.6-198811-I/en">https://www.itu.int/rec/T-REC-T.6-198811-I/en</a></p>

</section><!-- 6.5 -->

<section id="6.6">
<h3><a href="#6.6">6.6</a> UTF-8</h3>
<p>All text in DjVu files is Unicode-encoded using the UTF-8 encoding. <a class="bare" href="http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf">http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf</a></p>
</section><!-- 6.6 -->

<section id="6.7">
<h3><a href="#6.7">6.7</a> DjVuLibre</h3>
<p>An open-source reference implementation of this file format specification is available at <a class="bare" href="http://sourceforge.net/projects/djvu/">http://sourceforge.net/projects/djvu/</a>. Throughout this specification, there are numerous references to source files in this implementation.</p>
</section><!-- 6.7 -->
</section><!-- 6 -->

<section id="7">
<h2><a href="#7">7</a> Component pieces (IFF chunks) of DjVu documents and images</h2>

<p>This section describes the DjVu file format at a middle level. This includes types of chunks which can go into various types of documents but not a detailed layout of the contents of those chunks.</p>
<p>DjVu documents are IFF85 files (see <a href="#6.2">Reference 2</a> for details). The IFF85 structure provides a hierarchy of containers which hold various types of information in a DjVu file. The containers are called “chunks”. How the chunk is used (what it holds) can be determined by its “chunk type” or “chunk ID”. For example, the list of files contained in a multi-page document is held in the <span class="ck">DIRM</span> (“directory”) chunk; annotations are held in a <span class="ck">ANTz</span> chunk.</p>
<p><span class="ck">FORM</span> chunks are composite (contain other chunks). Their specific use is exposed by a secondary chunk ID. For example, a single page consists of several different chunks all contained within a single <span class="ck">FORM:DJVU</span> chunk. A multi-page document consists of several pages (and other chunks) all contained in a <span class="ck">FORM:DJVM</span> chunk.</p>
<p>This section discusses the various kinds of DjVu documents and the corresponding chunks of which they consist.</p>

<section id="7.1">
<h3><a href="#7.1">7.1</a> Single-page documents</h3>

<p>A single-page document is composed of a single <span class="ck">FORM:DVJU</span> composite chunk. This composite chunk always begins with one <span class="ck">INFO</span> chunk describing the image size, resolution and related information (see §<a href="#8.3.11">8.3.11</a>). The document contains exactly one DjVu image, whose content varies as described below.</p>

<section id="7.1.1">
<h4>7.1.1 Photo DjVu image</h4>
<p>Photo DjVu image files are best used for encoding photographic images in colors or in shades of gray. The data compression model relies on the IW44 wavelet representation. This format is designed such that the IW44 decoder is able to quickly perform progressive rendering of any image segment using only a small amount of memory. One or more additional <span class="ck">BG44</span> chunks contain the image data encoded with the IW44 representation. The image size specified in the <span class="ck">INFO</span> chunk and the image size specified in the IW44 data must be equal.</p>
</section><!-- 7.1.1 -->

<section id="7.1.2">
<h4>7.1.2 Bi-level DjVu image</h4>
<p>Bi-level DjVu image files are used to compress black and white images representing text and simple drawings. The JB2 data compression model uses the soft pattern-matching technique, which essentially consists of encoding each character by describing how it differs from a well-chosen already-encoded character. A <span class="ck">Sjbz</span> chunk contains the bi-level data encoded with the JB2 representation (see <a href="#11">Appendix 2</a>). The image size specified in the <span class="ck">INFO</span> chunk and the image size specified in the JB2 data must be equal.</p>
</section><!-- 7.1.2 -->

<section id="7.1.3">
<h4>7.1.3 Compound DjVu image</h4>
<p>Compound DjVu image files are an extremely efficient way to compress high-resolution compound document images containing both images and text, such as a page of a magazine. Compound DjVu files represent the document image using two layers. The <i>background layer</i> is used for encoding the pictures and the paper texture.</p>
<p>The <i>foreground layer</i> is used for encoding the text and the drawings. Additional chunks hold the components of either the foreground or the background layers.</p>
<p>The main component of the foreground layer is a bi-level image named the <i>foreground mask</i>. The pixel size of the foreground mask is equal to the size of the DjVu image. It contains a black-on-white representation of the text and the drawings. This image is encoded by a <span class="ck">Sjbz</span> chunk using the JB2 representation. There may also be a companion chunk <span class="ck">Djbz</span> containing a <i>shape dictionary</i> that defines bi-level shapes referenced by the <span class="ck">Sjbz</span> chunk.</p>

<section id="7.1.3.1">
<h5>7.1.3.1 Foreground encoding</h5>
<p>The foreground colors can be encoded according to two models:</p>
<ul>
<li>Using a small color image, the <i>foreground color image</i>, encoded as a single <span class="ck">FG44</span> chunk using the IW44 representation (see <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/IW44Image.h">IW44Image.h</a>).</li>
<li>By specifying one solid color per object described by the JB2-encoded mask. These <i>JB2 colors</i> are color-quantized and stored in a single <span class="ck">FGbz</span> chunk (see §<a href="#6.3.10">6.3.10</a>). Such compound DjVu images are rendered by painting each foreground object on top of the background color image using the solid color specified by the <span class="ck">FGbz</span> chunk.</li>
</ul>
</section><!-- 7.1.3.1 -->

<section id="7.1.3.2">
<h5>7.1.3.2 Background encoding</h5>
<p>The background layer is a color image, the <i>background color image</i>, encoded by an arbitrary number of <span class="ck">BG44</span> chunks containing successive IW44 refinements (see <a href="#10">Appendix 1</a>). The size of this image is computed by rounding up the quotient of the mask size by an integer sub-sampling factor ranging from 1 to 12. Most compound DjVu images use a background sub-sampling factor equal to 3. Smaller sub-sampling factors are adequate for images with a very rich paper texture. Larger sub-sampling factors are adequate for images containing no pictures.</p>
<p>There are no ordering or interleaving constraints on these chunks except that (a) the <span class="ck">INFO</span> chunk must appear first, and (b) the successive <span class="ck">BG44</span> refinements must appear with their natural order. The chunk order simply affects the progressive rendering of DjVu images in a web browser.</p>
</section><!-- 7.1.3.2 -->

<section id="7.1.3.3">
<h5>7.1.3.3 Alternative encodings</h5>
<p>Besides the JB2 and IW44 encoding schemes, the DjVu format supports alternative encdoding methods for its components.</p>
<p>The foreground mask may be represented by a single <span class="ck">Smmr</span> chunk instead of <span class="ck">Sjbz</span>. The <span class="ck">Smmr</span> chunk contains a bi-level image encoded with the Fax-G4/MMR method. Although the resulting files are typically six times larger, this capability can be useful when DjVu is used as a front-end for fax machines and scanners with embedded Fax-G4/MMR capabilities.</p>
<p>The background color image may be represented by a single <span class="ck">BGjp</span> chunk instead of several <span class="ck">BG44</span> chunks. The <span class="ck">BGjp</span> chunk contains a JPEG-encoded color image (see <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/JPEGDecoder.cpp">JPEGDecoder.cpp</a>). The resulting files are significantly larger and lack the progressivity of the usual DjVu files. This is useful because some scanners have embedded JPEG capabilities.</p>
<p>The foreground color image may be represented by a single <span class="ck">FGjp</span> chunk instead of a single <span class="ck">FG44</span> chunk. This is useful because some scanners have embedded JPEG capabilities.</p>
</section><!-- 7.1.3.3 -->

<section id="7.1.3.4">
<h5>7.1.3.4 Annotations and textual information</h5>
<p>All types of DjVu images may contain annotation chunks. Annotation chunks are used to describe hyperlinks, to specify more viewer settings (page background, initial zoom, etc.), and to hold metadata information. Annotations are contained in <span class="ck">ANTa</span> or <span class="ck">ANTz</span> chunks.</p>
<p>All types of DjVu image files may also contain a computer-readable description of the text appearing on the page. This information is contained in either a <span class="ck">TXTa</span> chunk or a <span class="ck">TXTz</span> chunk.</p>
</section><!-- 7.1.3.4 -->
</section><!-- 7.1.3 -->
</section><!-- 7.1 -->

<section id="7.2">
<h3><a href="#7.2">7.2</a> Multi-page documents</h3>
<p>A multi-page document is composed of a <span class="ck">FORM:DJVM</span> whose first chunk is a <span class="ck">DIRM</span> chunk containing the <i>document directory</i>. This directory lists all component files composing the given document, helps to access every component file and identifies the pages of the document.</p>
<p>In a <i>bundled</i> multi-page file, the component files are stored immediately after the <span class="ck">DIRM</span> chunk, within the <span class="ck">FORM:DJVM</span> composite chunk.</p>
<p>In an <i>indirect</i> multi-page file, the component files are stored in different files whose URLs are composed using information stored in the <span class="ck">DIRM</span> chunk.</p>

<section id="7.2.1">
<h4>7.2.1 Component files</h4>
<p>A multi-page DjVu document necessarily references other <span class="ck">FORM</span> (composite) chunks. Specifically:</p>
<ul>
<li>Each page is a single-page document (<span class="ck">FORM:DJVU</span> chunk).</li>
<li>Embedded thumbnails (if any) are contained in one or more <span class="ck">FORM:THUM</span> chunks.</li>
<li>Shared annotations (if any) and shape dictionaries (if any) are contained in one or more <span class="ck">FORM:DJVI</span> chunks.</li>
</ul>
<p>Each of these composite chunks (<span class="ck">FORM:DJVU</span>, <span class="ck">FORM:THUM</span>, <span class="ck">FORM:DJVI</span>) is a well-formed IFF byte stream in its own right and can be held in a separate disk file. In the context of a multi-page — either bundled or indirect — document, we refer to these composite chunks as <i>component files</i>.</p>
</section><!-- 7.2.1 -->

<section id="7.2.2">
<h4>7.2.2 Including shared information</h4>
<p>In many cases, efficiencies can be achieved by sharing JB2 shape definitions and/or annotations across pages. To facilitate this, any DjVu image file contained in a multi-page file may contain an <span class="ck">INCL</span> chunk containing the ID of a shared component file. The decoder processes the chunks contained in the shared component file as if the DjVu image file contained them. All relevant pages include this shared component file. Although they appear in several pages, these shared shapes are encoded only once in the document.</p>
<p>A shared component file is composed of a single <span class="ck">FORM:DJVI</span> potentially containing any information otherwise allowed in a DjVu image file (except for the <span class="ck">INFO</span> chunk of course).</p>
</section><!-- 7.2.2 -->
</section><!-- 7.2 -->
</section><!-- 7 -->

<section id="8">
<h2><a href="#8">8</a> Low-level chunk structure and definition</h2>
<p>This section describes the DjVu file format at a low level. This includes the binary layout of the IFF85 wrapper and, of course, the layout of each contained chunk.</p>

<section id="8.1">
<h3><a href="#8.1">8.1</a> Header</h3>
<p>The first four bytes of a DjVu file are <span class="hex">0x41 0x54 0x26 0x54</span>. This preamble is not part of the EA IFF85 format, but it is required in order to identify DjVu files.</p>
</section><!-- 8.1 -->

<section id="8.2">
<h3><a href="#8.2">8.2</a> DjVu file structure</h3>

<section id="8.2.1">
<h4>8.2.1 IFF wrapper</h4>
<p>An IFF file consists of a number of chunks. Each chunk is laid out in three fields:</p>
<table class="hoist">
<tr>
  <td><code>BYTE[4]</code></td>
  <td>Chunk ID. Describes the use of the chunk. The strings that identify the types of chunks used in DjVu are listed below.</td>
</tr>
<tr>
  <td><code>BE32</code></td>
  <td>The length of the data.</td>
</tr>
<tr>
  <td><code>BYTE[]</code></td>
  <td>The contained data.</td>
</tr>
</table>
<p>A chunk whose type is not recognized by the application is to be ignored. In the IFF format, chunks may be nested: a chunk may contain other chunks as part of its data. In the DjVu format, there is only one chunk at the outermost nesting level, a <span class="ck">FORM</span> chunk. All other chunks appear within the <span class="ck">FORM</span> chunk, sequentially, with no nesting.<sup>[<a id="note-8.2.1-1" href="./spec-comments.html#8.2.1-1">1</a>]</sup></p>
<p>Example:</p>
<table>
<tr>
  <td><span class="hex">00000000</span></td>
  <td><span class="hex">41 54 26 54</span></td>
  <td>"AT&amp;T"; magic described in §<a href="#8.1">8.1</a>.</td>
</tr>
<tr>
  <td><span class="hex">00000004</span></td>
  <td><span class="hex">46 4f 52 4d</span></td>
  <td>"FORM"; chunk ID = <span class="ck">FORM</span></td>
</tr>
<tr>
  <td><span class="hex">00000008</span></td>
  <td><span class="hex">00 00 68 a6</span></td>
  <td><span class="hex">0xa668</span> = 26970; length of this <span class="ck">FORM</span> chunk</td>
</tr>
<tr>
  <td><span class="hex">0000000b</span></td>
  <td><span class="hex">44 4a 56 55</span></td>
  <td>"DJVU"; first four bytes of contained data. Since this is a <span class="ck">FORM</span> chunk, this starts with the sub-identifier. This is a <span class="ck">FORM:DJVU</span> chunk, a single-page document.</td>
</tr>
</table>
</section><!-- 8.2.1 -->

<section id="8.2.2">
<h4>8.2.2 Chunk summary</h4>
<p>The chunks used in the DjVu file format are summarized in Table 1.</p>
<table class="hoist">
<caption>Table 1: chunk summary</caption>
<thead>
<tr>
  <td>Chunk ID</td>
  <td>Usage</td>
</tr>
</thead>
<tbody>
<tr>
  <td><span class="ck">FORM</span></td>
  <td>The composite chunk. The first four bytes of the <span class="ck">FORM</span> chunk are a secondary identifier. Such chunks are referred to as <span class="ck">FORM:XXXX</span> where "<span class="ck">XXXX</span>" stands for the secondary identifier.</td>
</tr>
<tr>
  <td><span class="ck">FORM:DJVM</span></td>
  <td>A multi-page DjVu document. Composite chunk that contains the <span class="ck">DIRM</span> chunk, possible shared/included chunks and subsequent <span class="ck">FORM:DJVU</span> chunks which make up a multi-page document.</td>
</tr>
<tr>
  <td><span class="ck">FORM:DJVU</span></td>
  <td>A DjVu page/single-page DjVu document. Composite chunk that contains the chunks that make up a page in a DjVu document.</td>
</tr>
<tr>
  <td><span class="ck">FORM:DJVI</span></td>
  <td>A “shared” DjVu file which is included via the <span class="ck">INCL</span> chunk. Shared annotations, shared shape dictionary.</td>
</tr>
<tr>
  <td><span class="ck">FORM:THUM</span></td>
  <td>Composite chunk that contains the <span class="ck">TH44</span> chunks that are the embedded thumbnails.</td>
</tr>
<tr>
  <td><span class="ck">DIRM</span></td>
  <td>Page name information for multi-page documents.</td>
</tr>
<tr>
  <td><span class="ck">NAVM</span></td>
  <td>Bookmark information.</td>
</tr>
<tr>
  <td><span class="ck">ANTa</span>, <span class="ck">ANTz</span></td>
  <td>Annotations, including both initial view settings and overlaid hyperlinks, text boxes, etc.</td>
</tr>
<tr>
  <td><span class="ck">TXTa</span>, <span class="ck">TXTz</span></td>
  <td>Unicode text and layout information.</td>
</tr>
<tr>
  <td><span class="ck">Djbz</span></td>
  <td>Shared shape table.</td>
</tr>
<tr>
  <td><span class="ck">Sjbz</span></td>
  <td>BZZ-compressed JB2 bitonal data used to store mask.</td>
</tr>
<tr>
  <td><span class="ck">FG44</span></td>
  <td>IW44 data used to store foreground.</td>
</tr>
<tr>
  <td><span class="ck">BG44</span></td>
  <td>IW44 data used to store background.</td>
</tr>
<tr>
  <td><span class="ck">TH44</span></td>
  <td>IW44 data used to store embedded thumbnail images.</td>
</tr>
<tr>
  <td><span class="ck">WMRM</span></td>
  <td>JB2 data required to remove a watermark.<sup>[<a id="note-8.2.2-1" href="./spec-comments.html#8.2.2-1">1</a>]</sup></td>
</tr>
<tr>
  <td><span class="ck">FGbz</span></td>
  <td>Color JB2 data. Provides a color for each [blit or shape?] in the corresponding <span class="ck">Sjbz</span> chunk.</td>
</tr>
<tr>
  <td><span class="ck">INFO</span></td>
  <td>Information about a DjVu page.</td>
</tr>
<tr>
  <td><span class="ck">INCL</span></td>
  <td>The ID of an included <span class="ck">FORM:DJVI</span> chunk.</td>
</tr>
<tr>
  <td><span class="ck">BGjp</span></td>
  <td>JPEG-encoded background.</td>
</tr>
<tr>
  <td><span class="ck">FGjp</span></td>
  <td>JPEG-encoded foreground.</td>
</tr>
<tr>
  <td><span class="ck">Smmr</span></td>
  <td>G4-encoded mask.</td>
</tr>
</tbody>
</table>
</section><!-- 8.2.2 -->
</section><!-- 8.2 -->

<section id="8.3">
<h3><a href="#8.3">8.3</a> IFF chunk types</h3>

<section id="8.3.1">
<h4>8.3.1 Container chunk: <span class="ck">FORM</span></h4>
<p>The <span class="ck">FORM</span> chunk is used as a chunk container. The first four bytes of the <span class="ck">FORM</span> chunk are a secondary ID used to identify the contained chunks.</p>

<section id="8.3.1.1">
<h5>8.3.1.1 <span class="ck">FORM:DJVM</span></h5>
<p>As discussed in §<a href="#7.2">7.2</a>, a multi-page DjVu document is composed of a single (composite) <span class="ck">FORM:DJVM</span> chunk. The first nested chunk is always a <span class="ck">DIRM</span> chunk containing the document directory (see <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/DjVmDir.cpp">DjVmDir.h</a>), which represents the list of the component files that make up the document. An optional <span class="ck">NAVM</span> chunk, which describes the outline of the document, may follow the <span class="ck">DIRM</span> chunk.</p>
<p>Example:</p>
<pre style="overflow:auto">
<span class="ck">FORM:DJVM</span> [126475 bytes]
  <span class="ck">DIRM</span> [59 bytes] Document directory (bundled, 3 files, 2 pages)
  <span class="ck">FORM:DJVI</span> [3493 bytes] <span class="filename">dict0002.iff</span>
  <span class="ck">FORM:DJVU</span> [115016 bytes] <span class="filename">p0001.djvu</span>
  <span class="ck">FORM:DJVU</span> [7869 bytes] <span class="filename">p0002.djvu</span>
</pre>
</section><!-- 8.3.1.1 -->

<section id="8.3.1.2">
<h5>8.3.1.2 <span class="ck">FORM:DJVU</span></h5>
<p>As discussed in §<a href="#7.1">7.1</a>, a single page in a DjVu document is contained in a single (composite) <span class="ck">FORM:DJVU</span> chunk. The nested first chunk must be the <span class="ck">INFO</span> chunk. The chunks after the <span class="ck">INFO</span> chunk may occur in any order, although the order of the <span class="ck">BG44</span> chunks, if there is more than one, is significant.</p>
<p>Example:</p>
<pre style="overflow:auto">
<span class="ck">FORM:DJVU</span> [26790 bytes]
  <span class="ck">INFO</span> [10 bytes] 2202 × 967, version 26, 300 dpi, gamma = 2.2
  <span class="ck">Sjbz</span> [13133 bytes] JB2 bi-level data
  <span class="ck">FG44</span> [185 bytes] IW44 data #1, 76 slices, version 1.2 (color), 184 × 81
  <span class="ck">BG44</span> [935 bytes] IW44 data #1, 74 slices, version 1.2 (color), 734 × 323
  <span class="ck">BG44</span> [1672 bytes] IW44 data #2, 10 slices
  <span class="ck">BG44</span> [815 bytes] IW44 data #3, 4 slices
  <span class="ck">BG44</span> [9976 bytes] IW44 data #4, 9 slices
</pre>
</section><!-- 8.3.1.2 -->

<section id="8.3.1.3">
<h5>8.3.1.3 <span class="ck">FORM:DJVI</span></h5>
<p>Multi-page DjVu documents can share information between pages by nesting a chunk inside a <span class="ck">FORM:DJVI</span> chunk (which is itself held inside the <span class="ck">FORM:DJVM</span> chunk) and referencing the contained chunk from within a page. Individual pages reference the shared chunks via the <span class="ck">INCL</span> chunk.</p>
<p>Example:</p>
<pre style="overflow:auto">
<span class="ck">FORM:DJVM</span> [126475 bytes]
  <span class="ck">DIRM</span> [59 bytes] Document directory (bundled, 3 files, 2 pages)
  <strong><span class="ck">FORM:DJVI</span> [3493 bytes] <span class="filename">dict0002.iff</span></strong>
    <strong><span class="ck">Djbz</span> [3481 bytes] JB2 shared dictionary</strong>
  <span class="ck">FORM:DJVU</span> [115016 bytes] <span class="filename">p0001.djvu</span>
    <span class="ck">INFO</span> [10 bytes] 2539 × 3295, version 25, 300 dpi, gamma = 2.2
    <strong><span class="ck">INCL</span> [12 bytes] Indirection chunk → <span class="filename">dict0002.iff</span></strong>
    <span class="ck">Sjbz</span> [70497 bytes] JB2 bi-level data
</pre>
</section><!-- 8.3.1.3 -->

<section id="8.3.1.4">
<h5>8.3.1.4 <span class="ck">FORM:THUM</span></h5>
<p>Pre-rendered thumbnails may be included. This allows very large documents to render thumbnails of pages without downloading and decoding them. <span class="ck">FORM:THUM</span> chunks contain several <span class="ck">TH44</span> chunks. Each of these chunks contains the thumbnails of the pages that follow.</p>
<p>Example:</p>
<pre style="overflow:auto">
<span class="ck">FORM:DJVM</span> [2272012 bytes]
  <span class="ck">DIRM</span> [108 bytes] Document directory (bundled, 7 files, 4 pages)
  <span class="ck">FORM:THUM</span> [5960 bytes] <span class="filename">p0001.thumb</span>
    <span class="ck">TH44</span> [5984 bytes] Thumbnail icon for page 1
  <span class="ck">FORM:DJVU</span> [1413380 bytes] <span class=filename">p0001.djvu</span>
    <span class="ck">INFO</span> [10 bytes] 4728 × 6300, version 25, 600 dpi, gamma = 2.2
    …
  <span class="ck">FORM:THUM</span> [12148 bytes] <span class="filename">p0004.thumb</span>
    <span class="ck">TH44</span> [3418 bytes] Thumbnail icon for page 2
    <span class="ck">TH44</span> [4150 bytes] Thumbnail icon for page 3
    <span class="ck">TH44</span> [4552 bytes] Thumbnail icon for page 4
  <span class="ck">FORM:DJVU</span> [777858 bytes] <span class="filename">p0002.djvu</span>
    …
</pre>
</section><!-- 8.3.1.4 -->
</section><!-- 8.3.1 -->

<section id="8.3.2">
<h4>8.3.2 Directory chunk: <span class="ck">DIRM</span></h4>
<p>As described in §<a href="#7.2">7.2</a>, a multi-page document will contain “component files” such as individual pages (<span class="ck">FORM:DJVU</span>) or shared annotations (<span class="ck">FORM:DJVI</span>).</p>
<p>The first contained chunk in a <span class="ck">FORM:DJVM</span> composite chunk is the <span class="ck">DIRM</span> chunk containing the <i>document directory</i>. It contains information the decoder will need to access the component files (see §<a href="#7.2">7.2</a>).</p>

<section id="8.3.2.1">
<h5>8.3.2.1 Unencoded data</h5>
<p>The first part of the <span class="ck">DIRM</span> chunk is unencoded:</p>
<table class="hoist">
<tr>
  <td><code>BYTE</code></td>
  <td><p>Bit 7 (the MSB) is the <i>bundled</i> flag: 1 for bundled, 0 for indirect.</p>
  <p>Bits 6 through 0 are the version, currently 1.</p></td>
</tr>
<tr>
  <td><code>BE16</code></td>
  <td>Number of component files.</td>
</tr>
<tr>
  <td><code>BE32[]</code></td>
  <td><p>When the document is a bundled document (i.e.&nbsp;the flag <var>bundled</var> is set), the header above is followed by the offsets of each of the component files within the <span class="ck">FORM:DJVM</span>. These offsets allow for random component file access.</p>
  <p>When the document is indirect, these offsets are omitted.</p></td>
</tr>
</table>
</section><!-- 8.3.2.1 -->

<section id="8.3.2.2">
<h5>8.3.2.2 BZZ-encoded data</h5>
<p>The rest of the chunk is entirely compressed with the BZZ general-purpose compressor. We describe now the data fed into (or retrieved from) the BZZ codec (see <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/BSByteStream.cpp">BSByteStream.cpp</a> and <a href="#13">Appendix 4</a>).</p>
<table class="hoist">
<tr>
  <td><code>BE24[]</code></td>
  <td>Size of each component file. May be 0 for indirect documents.</td>
</tr>
<tr>
  <td><code>BYTE[]</code></td>
  <td>Flag byte for each component file.<!-- TODO --></td>
</tr>
<tr>
  <td><code>ZSTR[]</code></td>
  <td>There are one to three zero-terminated strings per component file. The first string contains the ID of the component file. If <var>hasname</var> is set then there is a second string which contains the name of the component file (in the case of an indirect file, this is the disk filename). If <var>hastitle</var> is set, then there is a third string which contains the name of the component (for display — for example, alternate page numberings in the Foreword or Preface).</td>
</tr>
</table>
<p>Examples:</p>

<figure><!-- TODO -->
<pre>
81
00 03
00 00 00 54
00 00 0e 02
00 01 cf 52

00 0d ad
01 c1 50
00 1e c5
00
01
01
64 69 63 74 30 30 30 32 2e 69 66 66 00
70 30 30 30 31 2e 64 6a 76 75 00
70 30 30 30 32 2e 64 6a 76 75 00
</pre>
<figcaption></figcaption>
</figure>

<figure><!-- TODO -->
<pre>
01
00 03

00 0d ad
01 c1 50
00 1e c5
00
01
01
64 69 63 74 30 30 30 32 2e 69 66 66 00
70 30 30 30 31 2e 64 6a 76 75 00
70 30 30 30 32 2e 64 6a 76 75 00
</pre>
</figure>
<figcaption></figcaption>
</section><!-- 8.3.2.2 -->
</section><!-- 8.3.2 -->

<section id="8.3.3">
<h4>8.3.3 Document outline chunk: <span class="ck">NAVM</span></h4>
<p>The <span class="ck">NAVM</span> chunk contains bookmarks which describe an outline of the document. The intent is to allow content authors to create an electronic table of contents which gives users rapid access to various parts of the document.</p>
<p>This chunk is optional, but, if present, must immediately follow the <span class="ck">DIRM</span> chunk.</p>
<p>The entire chunk is BZZ-encoded and starts with a single field specifying the total number of bookmark records:</p>
<table class="hoist">
<tr>
  <td><code>BE16</code></td>
  <td>The total number of bookmarks in the document.</td>
</tr>
</table>
<p>And then the individual bookmark records, nested as necessary:</p>
<table class="hoist">
<tr>
  <td><code>BYTE</code></td>
  <td>The number of immediate child bookmark records.</td>
</tr>
<tr>
  <td><code>BE24</code></td>
  <td>Size of the description text.</td>
</tr>
<tr>
  <td><code>STR</code></td>
  <td>The description text.</td>
</tr>
<tr>
  <td><code>BE24</code></td>
  <td>Size of the URL text.</td>
</tr>
<tr>
  <td><code>STR</code></td>
  <td>The URL text. This may (and typically does) use the syntax desribed for the URLs in the <span class="ck">ANTa</span> chunk (and similarly, is not URL-encoded).</td>
</tr>
</table>
<p>Example (as passed to the BZZ codec):</p>
<p>Consider a small document outline as follows:</p>
<!-- TODO -->
<p>There is no hyperlink associated with the single root entry "Table of Contents". At a binary level, the chunk looks like this:
<table><!-- TODO -->
</table>
</section><!-- 8.3.3 -->

<section id="8.3.4">
<h4>8.3.4 Annotation chunk: <span class="ck">ANTa</span>, <span class="ck">ANTz</span></h4>
<p>Annotations are contained in <span class="ck">ANTa</span> or <span class="ck">ANTz</span> chunks. The <span class="ck">ANTa</span> chunks contain the annotation in plain text. The <span class="ck">ANTz</span> chunks contain the same information compressed with the BZZ encoder (see <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/BSByteStream.h">BSByteStream.h</a>).</p>
<p>The use of the <span class="ck">ANTa</span> chunk is discouraged.</p>
<p>Pages can share annotations using an <span class="ck">INCL</span> chunk as explained in §<a href="#7.2.2">7.2.2</a>. The complete annotation text is obtained by concatenating all annotation chunks present in the page. A restriction of the current reference library implementation limits the number of shared annotation files to one.<sup>[<a id="note-8.3.4-1" href="./spec-comments.html#8.3.4-1">1</a>]</sup></p>
<p>The syntax of the annotation text uses a simple parenthesized notation. All text is standard UTF-8.</p>

<section id="8.3.4.1">
<h5>8.3.4.1 Initial document view</h5>

<section id="8.3.4.1.1">
<h6>8.3.4.1.1 Background color</h6>
</section><!-- 8.3.4.1.1 -->

<section id="8.3.4.1.2">
<h6>8.3.4.1.2 Initial zoom</h6>
</section><!-- 8.3.4.1.2 -->

<section id="8.3.4.1.3">
<h6>8.3.4.1.3 Initial display level</h6>
</section><!-- 8.3.4.1.3 -->

<section id="8.3.4.1.4">
<h6>8.3.4.1.4 Alignment</h6>
</section><!-- 8.3.4.1.4 -->
</section><!-- 8.3.4.1 -->

<section id="8.3.4.2">
<h5>8.3.4.2 Maparea (overprinted annotations)</h5>

<section id="8.3.4.2.1">
<h6>8.3.4.2.1 <var>url</var></h6>
</section><!-- 8.3.4.2.1 -->

<section id="8.3.4.2.2">
<h6>8.3.4.2.2 <var>comment</var></h6>
</section><!-- 8.3.4.2.2 -->

<section id="8.3.4.2.3">
<h6>8.3.4.2.3 <var>area</var></h6>
</section><!-- 8.3.4.2.3 -->
</section><!-- 8.3.4.2 -->

</section><!-- 8.3.4 -->
</section><!-- 8.3 -->
</section><!-- 8 -->

<section id="9">
<h2><a href="#9">9</a> DjVu in the raw (binary and IFF-level dumps)</h2>
</section><!-- 9 -->

<section id="10">
<h2><a href="#10">10</a> Appendix 1: IW44 coding</h2>
</section><!-- 10 -->

<section id="11">
<h2><a href="#11">11</a> Appendix 2: JB2 coding</h2>

<section id="11.1">
<h3><a href="#11.1">11.1</a> General considerations</h3>
<p>Selection layer coding is used in compound DjVu images. In such images, there are three layers. The foreground layer is coded in one <span class="ck">FG44</span> chunk, and is rendered as described in <a href="#10">Appendix 1</a>. The background layer is coded in one or more <span class="ck">BG44</span> chunks, and is rendered as described in Appendix 1. The selection layer is coded using one <span class="ck">Sjbz</span> chunk. Black pixels in the selection layer specify those pixels that are to be rendered using the foreground color. All other pixels are to be rendered using the background color.</p>
<p>Black-and-white coding is used in bi-level DjVu images. In such images, there are three layres. The foreground layer is black. The background layer is white. The selection layer is coded using one <span class="ck">Sjbz</span> chunk. The selection layer specifies those pixels that are to be rendered in black. All other pixels are to be rendered in white.</p>
<p>An <span class="ck">Sjbz</span> chunk contains a single arithmetically-coded data stream, coded using the Z&prime;-Coder (<a href="#12">Appendix 3</a>). All data, including headers and record types, is coded in this arithmetically-coded stream.</p>
</section><!-- 11.1 -->

<section id="11.2">
<h3><a href="#11.2">11.2</a> Arithmetic coding</h3>
<p>The arithmetically-coded data in an <span class="ck">Sjbz</span> chunk consists logically of records. The record types are listed in Table 6, and described in §<a href="#11.4">11.4</a>. The records consist of fields. The fields present for records of each record type are listed in Table 6. The fields within a record are coded in the order listed in Table 6 for records of that type. Details of the coding for each field appear in §<a href="#11.5">11.5</a>.</p>
<p>A field may contain one or more data elements. The data elements consist of flags, pixel colors, and integers. Because of the nature of arithmetic coding, the records, fields, and data elements are not of fixed sizes, and do not necessarily begin on bit boundaries within the data stream.</p>
<p>Flags are binary decisions, each coded using the Z&prime;-Coder with a particular context. There are two different contexts for flags, the eventual image refinement context and the offset type context.</p>
<p>Pixel colors are binary decisions, coded using the Z&prime;-Coder with a particular context. For pixel colors, there are 3072 different contexts. There are 1024 contexts used for direct coding of bitmaps; these correspond to the
<math>
  <mrow>
    <msup>
      <mn>2</mn>
      <mn>10</mn>
    </msup>
    <mo>=</mo>
    <mn>1024</mn>
  </mrow>
</math>
different combinations of values that the pixels in the direct coding template can assume. There are 2048 contexts used for refinement coding of bitmaps; these correspond to the
<math>
  <mrow>
    <msup>
      <mn>2</mn>
      <mn>11</mn>
    </msup>
    <mo>=</mo>
    <mn>2048</mn>
  </mrow>
</math>
different combinations of values that the pixels in the refinement coding template can assume.</p>
<p>Integers are coded using the multivalue extension to the Z&prime;-Coder, described below. There are 15 contexts for coding multivalued integers, as described in Table 7.</p>

<section id="11.2.1">
<h4>11.2.1 Initialization of the Z&prime;-Coder</h4>
<p>All Z&prime;-Coder contexts are initialized to the value 0. This applies both to contexts used to encode single-bit values, including pixel colors, and to contexts that are part of an integer context used by the multivalue extension to the Z&prime;-Coder.</p>
</section><!-- 11.2.1 -->

<section id="11.2.2">
<h4>11.2.2 The multivalue extension to the Z&prime;-Coder for coding of numeric data</h4>
<p>Quantities that can take on multiple values are coded as integers using the multivalue extension to the Z&prime;-Coder. This extension of the Z&prime;-Coder allows all data in the bit stream to be coded using the same coder, the Z&prime;-Coder. There are 15 integer contexts, specified in Table 7. A single integer context includes a number of binary contexts.</p>
<p>One integer context consists of a binary decision tree. See Figure 1 for an example of part of such a tree. The root node of the tree corresponds to the decision about the sign of the number <var>n</var> being decoded. Each of the two sub-trees under the root corresponds to a set of decisions that eventually identify a range in which <var>n</var> lies. The sub-trees under the nodes corresponding to identified ranges are complete binary trees that identify the exact value of <var>n</var>.</p>
<p>Each node of the binary decision tree for an integer context maintains its own binary probability estimation context for the Z&prime;-Coder. The trees for different integer contexts are completely independent. Thus each node of a tree contains probability information conditioned on a conditioning context. The conditioning context consists of both the type of value being coded (i.e., the selection of the integer context), and of the values of the decisions coded so far when encoding the current integer.</p>
</section><!-- 11.2.2 -->

<section id="11.2.3">
<h4>11.2.3 Record types</h4>
<table>
<caption>Table 6: record types and fields coded for each record type</caption>
<thead>
<tr>
  <td>Record type coded value</td>
  <td>Record type</td>
  <td>Fields coded</td>
</tr>
</thead>
<tbody>
<tr>
  <td>0</td>
  <td>Start of image</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Image size</li>
      <li>Eventual image refinement flag</li>
    </ol>
  </td>
</tr>
<tr>
  <td>1</td>
  <td>New symbol, add to image and library</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Absolute symbol size</li>
      <li>Bitmap by direct coding</li>
      <li>Location relative to a previous symbol</li>
    </ol>
  </td>
</tr>
<tr>
  <td>2</td>
  <td>New symbol, add to library only</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Absolute symbol size</li>
      <li>Bitmap by direct coding</li>
    </ol>
  </td>
</tr>
<tr>
  <td>3</td>
  <td>New symbol, add to image only</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Absolute symbol size</li>
      <li>Bitmap by direct coding</li>
      <li>Location relative to a previous symbol</li>
    </ol>
  </td>
</tr>
<tr>
  <td>4</td>
  <td>Matched symbol with refinement, add to image and library</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Index of matching symbol in bitmap library</li>
      <li>Relative symbol size</li>
      <li>Bitmap by refinement coding</li>
      <li>Location relative to a previous symbol</li>
    </ol>
  </td>
</tr>
<tr>
  <td>5</td>
  <td>Matched symbol with refinement, add to library only</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Index of matching symbol in bitmap library</li>
      <li>Relative symbol size</li>
      <li>Bitmap by refinement coding</li>
    </ol>
  </td>
</tr>
<tr>
  <td>6</td>
  <td>Matched symbol with refinement, add to image only</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Index of matching symbol in bitmap library</li>
      <li>Relative symbol size</li>
      <li>Bitmap by refinement coding</li>
      <li>Location relative to a previous symbol</li>
    </ol>
  </td>
</tr>
<tr>
  <td>7</td>
  <td>Matched symbol, copy to image without refinement</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Index of matching symbol in bitmap library</li>
      <li>Location relative to a previous symbol</li>
    </ol>
  </td>
</tr>
<tr>
  <td>8</td>
  <td>Non-symbol data</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Absolute symbol size</li>
      <li>Bitmap by direct coding</li>
      <li>Absolute location</li>
    </ol>
  </td>
</tr>
<tr>
  <td>9</td>
  <td>Shared dictionary or reset</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Shared dictionary size</li>
    </ol>
  </td>
</tr>
<tr>
  <td>10</td>
  <td>Comment</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Comment length</li>
      <li>Comment data</li>
    </ol>
  </td>
</tr>
<tr>
  <td>11</td>
  <td>End of data</td>
  <td>
    <ol>
      <li>Record type</li>
    </ol>
  </td>
</tr>
</tbody>
</table>
</section><!-- 11.2.3 -->

<section id="11.2.4">
<h4>11.2.4 Fields and contexts</h4>
<table>
<caption>Table 7: multivalued integer contexts for arithmetic coding</caption>
<thead>
<tr>
  <td>Context name</td>
  <td>Integer data coded using this context</td>
</tr>
</thead>
<tbody>
<tr>
  <td>Record type</td>
  <td>Record type</td>
</tr>
<tr>
  <td>Image size</td>
  <td>Image height; image width</td>
</tr>
<tr>
  <td>Matching symbol index</td>
  <td>Index within the symbol library of the symbol matching the current symbol</td>
</tr>
<tr>
  <td>Symbol width</td>
  <td>Width of the current symbol in pixels</td>
</tr>
<tr>
  <td>Symbol height</td>
  <td>Height of the current symbol in pixels</td>
</tr>
<tr>
  <td>Symbol width difference</td>
  <td>Number of pixels that must be added to the width of the matching symbol to obtain the width of the current symbol</td>
</tr>
<tr>
  <td>Symbol height difference</td>
  <td>Number of pixels that must be added to the height of the matching symbol to obtain the height of the current symbol</td>
</tr>
<tr>
  <td>Symbol column number</td>
  <td>Column number of the absolute location of the left edge of the current symbol (leftmost column of the image is column number 1)</td>
</tr>
<tr>
  <td>Symbol row number</td>
  <td>Row number of the absolute location of the top edge of the current symbol (bottom row of the image is row number 1)</td>
</tr>
<tr>
  <td>Same line column offset</td>
  <td>Number of pixels that must be added to the column number of the right edge of the previous symbol on the current text line to obtain the column number of the left edge of the current symbol</td>
</tr>
<tr>
  <td>Same line row offset</td>
  <td>Number of pixels that must be added to the row number of the current baseline on the current text line to obtain the row number of the bottom edge of the current symbol</td>
</tr>
<tr>
  <td>New line column offset</td>
  <td>Number of pixels that must be added to the column number of the left edge of the first symbol on the current text line to obtain the column number of the left edge of the current symbol</td>
</tr>
<tr>
  <td>New line row offset</td>
  <td>Number of pixels that must be added to the row number of the bottom edge of the first symbol on the current text line to obtain the row number of the top edge of the current symbol</td>
</tr>
<tr>
  <td>Comment length</td>
  <td>The number of octets in the current comment</td>
</tr>
<tr>
  <td>Comment octet</td>
  <td>One octet in the current comment</td>
</tr>
<tr>
  <td>Dictionary size</td>
  <td>Number of shapes in the shared dictionary</td>
</tr>
</tbody>
</table>
</section><!-- 11.2.4 -->

<section id="11.2.5">
<h4>11.2.5 Coding phases</h4>
<figure>
<!-- TODO -->
<figcaption>
<p>Figure 1: Part of the coding tree for multivalue arithmetic coding. Each internal node represents one context with its own probability information, to be used by the Z&prime;-Coder. The square node at the root of the tree represents the Phase 1 decision, whether the integer <var>n</var> being coded is negative. The filled circles are the Phase 2 nodes, moving down the tree in ever-increasing ranges. The open circles represent Phase 3 decisions, traversing a complete binary sub-tree to reach the specific value of <var>n</var>. A decoded value of 0 indicates a left branch in this tree. A decoded value of 1 indicates a right branch.</p>
<p>This method allows high compression efficiency by allowing the coder to adapt to the statistics of the data. In effect, the binary probability information stored collectively in the nodes of the decision tree closely approximates the probability distribution of the underlying multivalued integer.</p>
<p>The allowable range of values for <var>n</var> is always specified. The smallest value that <var>n</var> could possibly take is denoted by <var>l</var>. The largest value that <var>n</var> could possibly take is denoted by <var>h</var>. When <var>l</var> and <var>h</var> are equal, <var>n</var> is equal to both of them, and no Z&prime;-Coder decoding is performed.</p>
<p>The decoder maintains a non-negative intermediate value <var>v</var>, defined as follows:
<math display="block">
  <mrow>
    <mi>v</mi>
    <mo>=</mo>
    <mrow>
      <mo stretchy="true" form="prefix">{</mo>
      <mtable>
        <mtr>
          <mtd>
            <mo stretchy="false" form="prefix">|</mo>
            <mi>n</mi>
            <mo stretchy="false" form="prefix">|</mo>
          </mtd>
          <mtd>
            <mrow>
              <mtext mathvariant="normal">if </mtext>
              <mspace width="0.333em" />
            </mrow>
            <mi>n</mi>
            <mo>≥</mo>
            <mn>0</mn>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mrow>
              <mo stretchy="false" form="prefix">|</mo>
              <mi>n</mi>
              <mo stretchy="false" form="prefix">|</mo>
            </mrow>
            <mo>−</mo>
            <mn>1</mn>
          </mtd>
          <mtd>
            <mrow>
              <mtext mathvariant="normal">if </mtext>
              <mspace width="0.333em" />
            </mrow>
            <mi>n</mi>
            <mo>&lt;</mo>
            <mn>0</mn>
            <mi>.</mi>
          </mtd>
        </mtr>
      </mtable>
    </mrow>
  </mrow>
</math>
At the end of the process of decoding an integer, <var>v</var> is converted to <var>n</var>, the value of the decoded integer.</p>
</figcaption>
</figure>
<p>The value of an integer is coded by making a sequence of binary decisions, each one narrowing the set of values that the integer can possibly take. The decisions are based on traversing a binary decision tree to one of its leaves. Note: although the tree conceptually has a large number of nodes, it is possible in an implementation to allocate memory only for those nodes actually traversed. Decoding proceeds in four phases.</p>

<section id="11.2.5.1">
<h5>11.2.5.1 Phase 1</h5>
<p>Phase 1 determines the sign of <var>n</var>. A value of 0 returned by the Z&prime;-Coder means that
<math>
  <mrow>
    <mi>n</mi>
    <mo>&lt;</mo>
    <mn>0</mn>
  </mrow>
</math>.
A value of 1 returned by the Z&prime;-Coder means that
<math>
  <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>0</mn>
  </mrow>
</math>.</p>
</section><!-- 11.2.5.1 -->

<section id="11.2.5.2">
<h5>11.2.5.2 Phase 2</h5>
<p>Phase 2 determines a range of possible values for <var>v</var>. The Z&prime;-Coder is invoked repeatedly to answer the question “Is the value of <var>v</var> in the range being tested?” The sequence of ranges tested is given in Table 8. A value of 0 returned by the Z&prime;-Coder means that <var>v</var> is not in the specified range, and the next range in the sequence must be tested. A value of 1 returned by the Z&prime;-Coder means that <var>v</var> is in the specified range, and decoding is to proceed to Phase 3.</p>
<table>
<caption>Table 8: sequence of ranges in which <var>v</var> may fall</caption>
<tr><td>0</td></tr>
<tr><td>1–2</td></tr>
<tr><td>3–6</td></tr>
<tr><td>7–14</td></tr>
<tr><td>15–30</td></tr>
<tr><td>31–62</td></tr>
<tr><td>63–126</td></tr>
<tr><td>127–254</td></tr>
<tr><td>255–510</td></tr>
<tr><td>511–1022</td></tr>
<tr><td>1023–2046</td></tr>
<tr><td>2047–4094</td></tr>
<tr><td>4095–8190</td></tr>
<tr><td>8191–16382</td></tr>
<tr><td>16383–32766</td></tr>
<tr><td>32767–65534</td></tr>
<tr><td>65535–131070</td></tr>
<tr><td>131071–262142</td></tr>
</table>
</section><!-- 11.2.5.2 -->

<section id="11.2.5.3">
<h5>11.2.5.3 Phase 3</h5>
<p>Phase 3 consists of determining the exact value of <var>v</var> within the range determined in Phase 2. If Phase 2 determined that
<math>
  <mrow>
    <mi>v</mi>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
</math>,
then Phase 3 is skipped. Otherwise, since the size of the range is a power of 2, the corresponding sub-tree is a complete binary tree. The sequence of coding decisions is based directly on traversing the binary tree. At each node, 0 returned by the Z&prime;-Coder means left branch (smaller values of <var>v</var>) and 1 means right branch (larger values of <var>v</var>. The bits returned by the Z&prime;-Coder during Phase 3 are the bits of <var>v</var>, most significant bit first.</p>
</section><!-- 11.2.5.3 -->

<section id="11.2.5.4">
<h5>11.2.5.4 Phase 4</h5>
<p>In Phase 4, the unsigned value <var>v</var> is converted to <var>n</var>, the signed value to be returned, as follows:
<math display="block">
  <mrow>
    <mi>n</mi>
    <mo>=</mo>
    <mrow>
      <mo stretchy="true" form="prefix">{</mo>
      <mtable>
        <mtr>
          <mtd>
            <mi>v</mi>
          </mtd>
          <mtd>
            <mrow>
              <mtext mathvariant="normal">if </mtext>
              <mspace width="0.333em" />
            </mrow>
            <mi>n</mi>
            <mrow>
              <mspace width="0.333em" />
              <mtext mathvariant="normal"> is non-negative, as determined in Phase 1;</mtext>
            </mrow>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mo>−</mo>
            <mi>v</mi>
            <mo>−</mo>
            <mn>1</mn>
          </mtd>
          <mtd>
            <mrow>
              <mtext mathvariant="normal">if </mtext>
              <mspace width="0.333em" />
            </mrow>
            <mi>n</mi>
            <mrow>
              <mspace width="0.333em" />
              <mtext mathvariant="normal"> is negative.</mtext>
            </mrow>
          </mtd>
        </mtr>
      </mtable>
    </mrow>
  </mrow>
</math></p>
<p>In any of the phases, if the input values of <var>l</var> and <var>h</var> (the range of allowable values) predetermine any decision, then the coding for that decision is not performed; the predetermined decision is assumed.</p>
<p>Each type of integer has its own set of binary contexts. Thus the probability information will reflect the underlying probability distribution of the particular type of integer. The Z&prime;-Coder probability state indices of all the binary nodes are initialized to 0.</p>
</section><!-- 11.2.5.4 -->
</section><!-- 11.2.5 -->
</section><!-- 11.2 -->

<section id="11.3">
<h3><a href="#11.3">11.3</a> Image reconstruction</h3>
<p>Records in an <span class="ck">Sjbz</span> chunk are interpreted in the order in which they appear. A "Start of data" record specifies the dimensions of the image. An "Image refinement data" record indicates […]<sup>[<a href="./spec-comments.html#11.3-1">1</a>]</sup>. An "End of data" record indicates the end of the <span class="ck">Sjbz</span> chunk. A "Comment" record contains uninterpreted data.</p>
<p>A record identified by any other record type describes one bitmap. The model used in DjVu for the selection layer is based on symbol-based coding. Bitmaps are placed into the reconstructed image as follows: The image is initially entirely white. When a bitmap is placed into the image, the pixels that are black in the current symbol become black at the appropriate position in the reconstructed image. Once a pixel in the reconstructed image becomes black, it remains black.</p>
<p>Because symbols in the document images are often similar to each other, it is often possible to obtain more efficient coding by making use of previously coded symbols. As symbols are decoded, their bitmaps may be placed into a symbol bitmap library. There is exactly one symbol bitmap library. Once a symbol has been placed into the symbol bitmap library, later records may cause copies of the symbol to be placed into the image, or may define a new bitmap by refining the bitmap in the library.</p>
<p>Depending on the record type, the symbol bitmap may be described by direct coding, by refinement coding, or by a copy operation. In direct coding, all pixels of the bitmap are coded directly, without reference to any other bitmap. In refinement coding, all pixels of the bitmap are also coded directly, but a bitmap in the library is used to make the coding more efficient. In a copy operation, the pixels of the bitmap are the same as the pixels of a bitmap in the library.</p>
<p>Depending on the record type, the bitmap may or may not be placed into the image. If the bitmap is placed into the image, then depending on the record type, it may be placed either at an absolute location or at a location relative to a previously placed bitmap.</p>
<p>Depending on the record type, the bitmap may or may not be placed into the symbol bitmap library. The first symbol placed into the library has index 0. Subsequent symbols are assigned consecutive integer indices.</p>
<p>The pixels of the reconstructed image are arranged in a rectangular coordinate system. For the pixel in the lower left corner of the image, the column number is 1 and the row number is 1. All coordinates refer to the pixels themselves, not to the edges between pixels.</p>
</section><!-- 11.3 -->

<section id="11.4">
<h3><a href="#11.4">11.4</a> Records</h3>
<p>Records in <span class="ck">Sjbz</span> chunks have the following interpretations.</p>

<section id="11.4.1">
<h4>11.4.1 Start of image</h4>
<p>This record is the first record in an <span class="ck">Sjbz</span> chunk. It specifies the dimensions of the image.</p>
</section><!-- 11.4.1 -->

<section id="11.4.2">
<h4>11.4.2 New symbol, add to image and library</h4>
<p>This record specifies the bitmap of a symbol that is coded directly and placed into the reconstructed image and into the symbol bitmap library.</p>
</section><!-- 11.4.2 -->

<section id="11.4.3">
<h4>11.4.3 New symbol, add to library only</h4>
<p>This record specifies the bitmap of a symbol that is coded directly and placed into the symbol bitmap library but not into the image.</p>
</section><!-- 11.4.3 -->

<section id="11.4.4">
<h4>11.4.4 New symbol, add to image only</h4>
<p>This record specifies the bitmap of a symbol that is coded directly and placed into the reconstructed image but not into the symbol bitmap library.</p>
</section><!-- 11.4.4 -->

<section id="11.4.5">
<h4>11.4.5 Matched symbol with refinement, add to image and library</h4>
<p>This record specifies the bitmap of a symbol that is coded by refinement of a symbol in the symbol bitmap library and placed into the reconstructed image and into the symbol bitmap library.</p>
</section><!-- 11.4.5 -->

<section id="11.4.6">
<h4>11.4.6 Matched symbol with refinement, add to library only</h4>
<p>This record specifies the bitmap of a symbol that is coded by refinement of a symbol in the symbol bitmap library and placed into the symbol bitmap library, but not into the reconstructed image.</p>
</section><!-- 11.4.6 -->

<section id="11.4.7">
<h4>11.4.7 Matched symbol with refinement, add to image only</h4>
<p>This record specifies the bitmap of a symbol that is coded by refinement of a symbol in the symbol bitmap library and placed into the reconstructed image, but not into the symbol bitmap library.</p>
</section><!-- 11.4.7 -->

<section id="11.4.8">
<h4>11.4.8 Matched symbol, copy to image without refinement</h4>
<p>This record specifies the location at which the bitmap of a symbol in the symbol bitmap library is to be placed into the reconstructed image.</p>
</section><!-- 11.4.8 -->

<section id="11.4.9">
<h4>11.4.9 Non-symbol data</h4>
<p>This record specifies a direct-coded bitmap to be placed at an absolute location in the reconstructed image. A bitmap of non-symbol data is not placed into the symbol bitmap library.</p>
</section><!-- 11.4.9 -->

<section id="11.4.10">
<h4>11.4.10 Shared dictionary or reset</h4>
<p>This record is overloaded and its meaning depends on its context. If the record occurs before a "Start of data" record, then it is a "Required dictionary" record. If the record occurs after a "Start of data" record then it is a "Reset" record.</p>

<section id="11.4.10.1">
<h5>11.4.10.1 Shared shape dictionaries</h5>
</section><!-- 11.4.10.1 -->

<section id="11.4.10.2">
<h5>11.4.10.2 Numcoder reset</h5>
</section><!-- 11.4.10.2 -->

<section id="11.4.10.3">
<h5>11.4.10.3 Record types in a shared dictionary</h5>
</section><!-- 11.4.10.3 -->
</section><!-- 11.4.10 -->

<section id="11.4.11">
<h4>11.4.11 Comment</h4>
</section><!-- 11.4.11 -->

<section id="11.4.12">
<h4>11.4.12 End of data</h4>
</section><!-- 11.4.12 -->

</section><!-- 11.4 -->

</section><!-- 11 -->

<section id="12">
<h2><a href="#12">12</a> Appendix 3: Z&prime; coding</h2>
<p>The Z&prime;-Coder is an approximate binary arithmetic coder. Decoding proceeds as follows.<sup>[<a id="note-12-1" href="./spec-comments.html#12-1">1</a>]</sup></p>
<p>See also files <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/ZPCodec.h">ZPCodec.h</a> and <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/ZPCodec.cpp">ZPCodec.cpp</a> in DjVuLibre.</p>

<section id="12.1">
<h3><a href="#12.1">12.1</a> Registers and data storage</h3>
<p>In Figure 1 and Figure 2, the values of variables <var>A</var>, <var>C</var>, <var>D</var>, and <var>Z</var> are stored in registers of at least 16 bits each. <var>A</var> and <var>C</var> retain their values between invocations of the Z&prime;-Coder. Note: if register overflow can be ignored, storing variables <var>A</var> and <var>C</var> in registers of exactly 16 bits allows a simplification of lines 11, 12, 16, and 17 of Figure 1 and lines 8, 9, 12, and 13 of Figure 2.</p>
<p>At the beginning of a chunk, the values of <var>A</var> and <var>C</var> are reinitialized. When the decoder is decoding a chunk, it may require more bits than are present within the chunk’s data. In this case, all additional required bits are to be assumed by the decoder to be 1. If there are excess bits at the end of a chunk, they are ignored.</p>
<p><var>K</var> is conceptually an array with a single 8-bit entry for each binary decision context. (In practice, <var>K</var> consists of a number of of individual values, arrays, and tree nodes, but each one has a specific address and a single 8-bit value at any time.) This array is indexed by the value of <var>i</var>, which is the input to the decoder.
<math>
  <mrow>
    <mi>K</mi>
    <mo stretchy="false" form="prefix">[</mo>
    <mi>i</mi>
    <mo stretchy="false" form="postfix">]</mo>
  </mrow>
</math>
is the current value of the probability state index for context <var>i</var>.
<math>
  <mrow>
    <mi>K</mi>
    <mo stretchy="false" form="prefix">[</mo>
    <mi>i</mi>
    <mo stretchy="false" form="postfix">]</mo>
  </mrow>
</math>
may be updated as part of the decoding process.</p>
<p>In pass-through mode, the decoder is invoked with no input argument. No context is involved.</p>
<p><var>B</var> is the 1-bit value returned by the decoder.</p>
<p>The Z&prime;-Coder is state-based. Decoding is governed by four fixed tables, given in Table 9. The tables are indexed by
<math>
  <mrow>
    <mi>K</mi>
    <mo stretchy="false" form="prefix">[</mo>
    <mi>i</mi>
    <mo stretchy="false" form="postfix">]</mo>
  </mrow>
</math>,
the probability state index for the current context. All probability state indices are initialized to 0. That is, at the beginning of coding, for all <var>i</var>,
<math>
  <mrow>
    <mi>K</mi>
    <mo stretchy="false" form="prefix">[</mo>
    <mi>i</mi>
    <mo stretchy="false" form="postfix">]</mo>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
</math>.
These values are not reinitialized at the beginning of chunks after the first.</p>
<p>The more probably symbol is denoted by MPS. The MPS is 1 if the probability state index is an odd integer, and 0 if the probability state index is an even integer. The less probable symbol is denoted by LPS. The LPS is 0 if the probability state index is an odd integer, and 1 if the probability state context is an even integer.</p>
<p>
<math>
  <msub>
    <mi>Δ</mi>
    <mi>k</mi>
  </msub>
</math>
is the amount by which the current arithmetic coding interval is reduced if the decoded symbol is the MPS.
<math>
  <msub>
    <mi>θ</mi>
    <mi>k</mi>
  </msub>
</math>
is the threshold above which an MPS triggers a probability state update.
<math>
  <msub>
    <mi>μ</mi>
    <mi>k</mi>
  </msub>
</math>
is the next probability state index for context <var>k</var> after an MPS triggers a probability state index update. An LPS always triggers a probability state index update.
<math>
  <msub>
    <mi>λ</mi>
    <mi>k</mi>
  </msub>
</math>
is the next probability state index for context <var>k</var> after an LPS.</p>
</section><!-- 12.1 -->

<section id="12.2">
<h3><a href="#12.2">12.2</a> Initialization</h3>
<p>Initially, <var>A</var> is set to <span class="hex">0x0000</span>. Two octets are read from the input data stream into the lowest 16 bits of <var>C</var>. If the bits of <var>C</var> are numbered such that bit 15 is the most significant bit and bit 0 is the least significant bit, then the first input octet is stored in bits 15 through 8, and the second input octet is stored in bits 7 through 0.</p>
</section><!-- 12.2 -->

<section id="12.3">
<h3><a href="#12.3">12.3</a> Decoding</h3>
<p>Figure 1 shows the steps involved in decoding a single binary decision. The input to the decoder is the index <var>i</var> of the appropriate context for the binary decision being decoded. The output from the decoder is a single bit <var>B</var>.</p>
<figure id="figure-1">
<pre>
<code>Z := A + Δ<sub>K[i]</sub></code>
<code>D := 0x6000 + (Z + A)/4</code>
<code>if (Z &gt; D) { Z := D }</code>
<code>if (C &gt; Z) {</code>
    <code>B := K[i] mod 2</code>
    <code>if (A &geq; θ<sub>K[i]</sub>) { K[i] = μ<sub>K[i]</sub> }</code>
    <code>A := Z</code>
<code>}</code>
<code>else {</code>
    <code>B := 1 - (K[i] mod 2)</code>
    <code>A := A + 0x10000 - Z</code>
    <code>C := C + 0x10000 - Z</code>
    <code>K[i] = λ<sub>K[i]</sub></code>
<code>}</code>
<code>while (A &geq; 0x8000) {</code>
    <code>A := A + A - 0x10000</code>
    <code>A := C + C - 0x10000 + next code bit</code>
<code>}</code>
<code>return B</code>
</pre>
<figcaption>Figure 1: decoder for the Z&prime;-Coder</figcaption>
</figure>

<section id="12.3.1">
<h4>12.3.1 Notes on specific lines of Figure 1</h4>
<dl>
<dt>Line 2</dt>
<dd>The division is a right shift, discarding the two least significant bits.</dd>
<dt>Lines 4–8</dt>
<dd>These lines are executed when the decoded bit is the MPS.</dd>
<dt>Line 5</dt>
<dd>This line determines the MPS from from the parity of the probability state index.</dd>
<dt>Line 6</dt>
<dd>Sometimes an MPS event triggers an update of the probability state index, based on the value of
<math>
  <msub>
    <mi>θ</mi>
    <mi>k</mi>
  </msub>
</math>.
Note that when the probability state index
<math>
  <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
</math>
or
<math>
  <mrow>
    <mi>k</mi>
    <mo>&gt;</mo><!-- FIXME -->
    <mn>83</mn>
  </mrow>
</math>,
<math>
  <mrow>
    <msub>
      <mi>θ</mi>
      <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
</math>,
so an MPS will trigger an update of the probability state index. All probability state indices are initialized to 0, but the first coded decision for a context causes the index to become at least 83. When
<math>
  <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
</math>
or
<math>
  <mrow>
    <mi>k</mi>
    <mo>≥</mo>
    <mn>83</mn>
  </mrow>
</math>,
the probability estimate for the context is in its early estimation phase. When
<math>
  <mrow>
    <mn>0</mn>
    <mo>&lt;</mo>
    <mi>k</mi>
    <mo>&lt;</mo>
    <mn>83</mn>
  </mrow>
</math>,
the probability estimate for the context is in its steady-state phase, which it never leaves.</dd>
<dt>Lines 9–14</dt>
<dd>These lines are executed when the decoded bit is the LPS.</dd>
<dt>Line 10</dt>
<dd>This line determines the LPS from the parity of the probability state index.</dd>
<dt>Line 13</dt>
<dd>An LPS always triggers an update of the probability state index.</dd>
<dt>Lines 15–18</dt>
<dd>When the values in the registers are too large, they must be renormalized.</dd>
<dt>Lines 16–17</dt>
<dd>
<math>
  <mrow>
    <mi>A</mi>
    <mo>+</mo>
    <mi>A</mi>
  </mrow>
</math>
and
<math>
  <mrow>
    <mi>C</mi>
    <mo>+</mo>
    <mi>C</mi>
  </mrow>
</math>
may be accomplished by left shifts, leaving the least significant bit equal to 0.</dd>
<dt>Line 17</dt>
<dd>The least significant bit of <var>C</var> is filled with the next bit from the input stream. Bits are taken from each octet in the input stream most significant bit first.</dd>
</dl>
</section><!-- 12.3.1 -->
</section><!-- 12.3 -->

<section id="12.4">
<h3><a href="#12.4">12.4</a> Pass-through decoding</h3>
<p>Figure 2 shows the steps involved in decoding a single binary decision using the Z&prime;-Coder in pass-through mode. No input is required. No context is involved. No probability state index values are updated. The output from the decoder is the single bit <var>B</var>.</p>
<figure id="figure-2">
<pre>
<code>Z := 0x8000 + (A + A + A)/8</code>
<code>if (C &gt; Z) {</code>
    <code>B := 0</code>
    <code>A := Z</code>
<code>}</code>
<code>else {</code>
    <code>B := 1</code>
    <code>A := A + 0x10000 - Z</code>
    <code>C := C + 0x10000 - Z</code>
<code>}</code>
<code>while (A &geq; 0x8000) {</code>
    <code>A := A + A - 0x10000</code>
    <code>A := C + C - 0x10000 + next code bit</code>
<code>}</code>
<code>return B</code>
</pre>
<figcaption>Figure 2: decoder for the Z&prime;-Coder operating in pass-through mode</figcaption>
</figure>

<section id="12.4.1">
<h4>12.4.1 Notes on specific lines of Figure 2</h4>
<dl>
<dt>Line 1</dt>
<dd>The division is a right shift, discarding the three least significant bits.</dd>
<dt>Lines 2–5</dt>
<dd>These lines are executed when the decoded bit is 0.</dd>
<dt>Lines 6–10</dt>
<dd>These lines are executed when the decoded bit is 1.</dd>
<dt>Lines 11–14</dt>
<dd>When the values in the registers are too large, they must be renormalized.</dd>
<dt>Lines 12–13</dt>
<dd>
<math>
  <mrow>
    <mi>A</mi>
    <mo>+</mo>
    <mi>A</mi>
  </mrow>
</math>
and
<math>
  <mrow>
    <mi>C</mi>
    <mo>+</mo>
    <mi>C</mi>
  </mrow>
</math>
may be accomplished by left shifts, leaving the least significant bit equal to 0.</dd>
<dt>Line 13</dt>
<dd>The least significant bit of <var>C</var> is filled with the next bit from the input stream. Bits are taken from each octet in the input stream most significant bit first.</dd>
</dl>
</section><!-- 12.4.1 -->
</section><!-- 12.4 -->
</section><!-- 12 -->

<section id="13">
<h2><a href="#13">13</a> Appendix 4: BZZ coding</h2>
<p>Numerous streams in the DjVu file format are compressed using the general-purpose compressor described here called “BZZ”. BZZ transforms the input data using the well-documented Burrows–Wheeler transform. However, the traditional “Move To Front” permutation table is augmented with a frequency estimation provided by the Z&prime;-Coder.</p>
<p>See also file <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/BSByteStream.cpp">BSByteStream.cpp</a>.</p>

<section id="13.1">
<h3><a href="#13.1">13.1</a> Encoding</h3>
<p>BZZ first takes as input a 24-bit integer as block size between 10K and 4M and an input stream (to be compressed). The stream is partitioned into blocks terminated with a special <code>&langle;EOB&rangle;</code> symbol. It is then transformed using the well-documented Burrows–Wheeler (BW or “block sorting”) transform. Then, one block at a time, the block size and resulting output stream are passed as input to be compressed using the Z&prime;-Coder (<a href="#12">Appendix 3</a>).</p>
</section><!-- 13.1 -->

<section id="13.2">
<h3><a href="#13.2">13.2</a> Decoding</h3>
<p>We describe the decoding algorithm by means of pseudo-code.</p>

<section id="13.2.1">
<h4>13.2.1 Decoding pseudo-code</h4>
<!-- TODO -->
</section><!-- 13.2.1 -->

<section id="13.2.2">
<h4>13.2.2 Notes</h4>

<section id="13.2.2.1">
<h5>13.2.2.1 Overview of decoding a block</h5>
<p>For each block, one must decode</p>
<ul>
<li>the block size (with <code>decode_raw</code>)</li>
<li>the estimation speed <code>FSHIFT ∈ {0, 1, 2}</code> (two bits<sup>[<a id="note-13.2.2.1-1" href="./spec-comments.html#13.2.2.1-1">1</a>]</sup> with the pass-through decoder)</li>
<li>the sequence of symbols representing the Burrows–Wheeler transform of the block. At this point, the sequence of symbols is logically encoded as a sequence of numbers representing the position of each symbol in the MTF array.</li>
</ul>
<p>Then one must perform the inverse Burrows–Wheeler transform to recover the decoded block.</p>
<p>The following points are significant when recovering the BWT and are discussed below:</p>
<ul>
<li>The MTF array is reordered after decoding each number.</li>
<li>The numbers themselves are arithmetically encoded.</li>
</ul>
</section><!-- 13.2.2.1 -->

<section id="13.2.2.2">
<h5>13.2.2.2 MTF array reordering</h5>
<p>The MTF array contains 256 bytes initialized with the identity mapping, that is <code>MTF[0] = 0</code>, <code>MTF[1] = 1</code>, … , <code>MTF[255] = 255</code>.</p>
<p>Whenever one decodes a number <code>MTFNO</code>, the corresponding symbol to store in the Burrows–Wheeler buffer is <code>MTF[MTFNO]</code> (except for the <code>&langle;EOB&rangle;</code> symbol — see §<a href="#13.2.2.3">13.2.2.3</a>) and the contents of the MTF array are rotated. The rotation moves the symbol that was at position <code>MTF[MTFNO]</code><!-- FIXME --> to a position <code>M</code> that can be 0, 1, 2, or 3. Meanwhile the symbols <code>MTF[M]</code> to <code>MTF[MTFNO - 1]</code> are moved to positions <code>M + 1</code> to <code>MTFNO</code>.</p>
<p>The position <code>M</code> is chosen using an estimate of the frequency of the symbol <code>MTF[MTFNO]</code>. One strives to position the most frequent symbols at the beginning of the MTF array. To that end, one maintains an array <code>FREQ[0..3]</code> that contains numbers representative of the instantaneous frequencies of the symbols <code>MTF[0..3]</code>.</p>
<p>Of course this array must also be “rotated” when the rotation of the MTF array affects its first four elements.</p>
<p>Consider the frequency
<math>
  <mi>F</mi>
  <mo stretchy="false" form="prefix">(</mo>
  <mi>T</mi>
  <mo stretchy="false" form="postfix">)</mo>
</math>
of a particular symbol <var>S</var> measured after decoding the <var>T</var>th symbol. Ideally,
<math display="block">
  <mrow>
    <mi>F</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>=</mo>
    <mi>λ</mi>
    <mi>F</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo>−</mo>
    <mn>1</mn>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>+</mo>
    <mi>D</mi>
  </mrow>
</math>
where</p>
<ul>
<li>
<math>
  <mrow>
    <mn>0</mn>
    <mo>&lt;</mo>
    <mi>λ</mi>
    <mo>≤</mo>
    <mn>1</mn>
  </mrow>
</math>.
This models how quickly one forgets past information, and
</li>
<li>
<math>
  <mrow>
    <mi>D</mi>
    <mo>=</mo>
    <mn>1</mn>
  </mrow>
</math>
if the <var>T</var>th symbol is <var>S</var>, and
<math>
  <mrow>
    <mi>D</mi>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
</math>
otherwise. This allows
<math>
  <mi>F</mi>
  <mo stretchy="false" form="prefix">(</mo>
  <mi>T</mi>
  <mo stretchy="false" form="postfix">)</mo>
</math>
to grow each time the symbol <var>S</var> occurs.
</li>
</ul>
<p>To avoid multiplying all the frequencies by <math><mi>λ</mi></math>, the <code>FREQ</code> array contains instead
<math display="block">
  <mrow>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>=</mo>
    <mi>F</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo stretchy="false" form="postfix">)</mo>
    <mi>/</mi>
    <msup>
      <mi>λ</mi>
      <mi>T</mi>
    </msup>
  </mrow>
</math>
It is then easy to see that
<math display="block">
  <mrow>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>=</mo>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo>−</mo>
    <mn>1</mn>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>+</mo>
    <mi>D</mi>
    <mi>/</mi>
    <msup>
      <mi>λ</mi>
      <mi>T</mi>
    </msup>
  </mrow>
</math>
Therefore we only need to update the <var>G</var> corresponding to the symbol being decoded (i.e.&nbsp;<math>
  <mrow>
    <mi>D</mi>
    <mo>=</mo>
    <mn>1</mn>
  </mrow>
</math>),
since the <var>G</var> for the other symbols does not change.</p>
<p>A dedicated variable <code>FADD</code> contains
<math>
  <mrow>
    <msup>
      <mi>λ</mi>
      <mi>T</mi>
    </msup>
  </mrow>
</math>.
Before each rotation we divide <code>FADD</code> by 
<math>
  <mrow>
    <msup>
      <mi>λ</mi>
      <mi>T</mi>
    </msup>
  </mrow>
</math>.
This is accomplished by the line
<pre>
<code>FADD = FADD + SHIFTRIGHT(FADD, FSHIFT)</code>
</pre>
<p>The values 0, 1 or 2 of variable <code>FSHIFT</code> correspond to
<math>
  <mrow>
    <mi>λ</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mi>/</mi>
    <mn>2</mn>
  </mrow>
</math>,
<math><mn>2</mn><mi>/</mi><mn>3</mn></math>, or
<math><mn>4</mn><mi>/</mi><mn>5</mn></math>.
To avoid overflows we divide everything (<code>FADD</code> and <code>FREQ[0..3]</code>) by <code>0x10000000</code> whenever <code>FADD</code> becomes bigger than <code>0x10000000</code>. This happens rarely enough to take very little time.</p>
<p>The
<math>
  <mi>G</mi>
  <mo stretchy="false" form="prefix">(</mo>
  <mi>T</mi>
  <mo stretchy="false" form="postfix">)</mo>
</math>
of the freshly decoded symbol is therefore
<math>
  <mrow>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo>−</mo>
    <mn>1</mn>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>+</mo>
  </mrow>
</math><code>FADD</code>.
We can only compute this exactly when <math><mi>S</mi></math> is one of the first four symbols of the MTF because we only store <code>FREQ[0..3]</code>. If the decoded number <code>MTFNO</code> is greater than 3, we assume that 
<math>
  <mrow>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo>−</mo>
    <mn>1</mn>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
</math>
and simply consider 
<math>
  <mrow>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>=</mo>
  </mrow>
</math><code>FADD</code>.</p>
<p>The number <code>M</code> is then chosen to make sure the array <code>FREQ</code> remains sorted in decreasing order after the rotation.</p>
</section><!-- 13.2.2.2 -->

<section id="13.2.2.3">
<h5>13.2.2.3 Decoding the number <code>MTFNO</code></h5>
<p>Now we can discuss how the numbers <code>MTFNO</code> are stored. There are 262 arithmetic coding contexts. These are initialized to zero at the beginning of the stream decoding process. They should <em>not</em> be reset to zero at the beginning of the block decoding process.</p>
<p>Because the most frequently used symbols should appear near the front of the array, we expect small values for <code>MTFNO</code> (the index into the MTF array). By design, the number of bits and the number of contexts required to decode increases for larger values of <code>MTFNO</code>:</p>
<ul>
<li>A first bit is decoded using context 0, 1 or 2. Context 0 or 1 is used if the previous <code>MTFNO</code> was 0 or 1. Otherwise context 2 is used. If this bit is set, the new <code>MTFNO</code> is 0.</li>
<li>Otherwise a second bit is decoded using context 3, 4 or 5. Context 3 or 4 is used if the previous <code>MTFNO</code> was 0 or 1. Otherwise context 5 is used. If this bit is set, the new <code>MTFNO</code> is 1.</li>
<li>Otherwise a third bit is decoded using context 6. If this bit is set, the new <code>MTFNO</code> is obtained by adding 2 to a 1-bit number decoded with <code>decode_bin</code> using context 7.</li>
<li>Otherwise a fourth bit is decoded using context 8. If this bit is set, the new <code>MTFNO</code> is obtained by adding 4 to a 2-bit number decoded with <code>decode_bin</code> using contexts <code>9..11</code>.</li>
<li>And so forth until…</li>
<li>Otherwise a ninth bit is decoded using context 132. If this bit is set, the new <code>MTFNO</code> is obtained by adding 128 to a 7-bit number decoded with <code>decode_bin</code> using contexts <code>133..261</code>.</li>
<li>Otherwise the next symbol is the <code>&langle;EOB&rangle;</code> symbol. Since there is only one <code>&langle;EOB&rangle;</code> symbol, we store a zero in the Burrows–Wheeler buffer and record its position in variable <code>MARKERPOS</code>.</li>
</ul>
</section><!-- 13.2.2.3 -->

<section id="13.2.2.4">
<h5>13.2.2.4 Inverse Burrows–Wheeler transform</h5>
<p>After decoding the <code>BLOCKSIZE</code> symbols composing the Burrows–Wheeler buffer, we need to perform the inverse Burrows–Wheeler transform to recover the <code>BLOCKSIZE - 1</code> decoded bytes followed by the <code>&langle;EOB&rangle;</code> symbol.</p>
<p>To start, we</p>
<ul>
<li>copy the buffer into an array <code>POSC[0..BLOCKSIZE - 1]</code>,</li>
<li>prepare an array <code>COUNT[0..255]</code> that counts how many occurrences of each symbol are found,</li>
<li>prepare an array <code>POSN[0..BLOCKSIZE - 1]</code> that indicates the rank of each occurrence of a symbol in the buffer.</li>
</ul>
<p>Imagine that we are sorting the buffer in symbol order (<code>&langle;EOB&rangle;</code> being the smallest symbol). The buffer would be composed of a single <code>&langle;EOB&rangle;</code>, followed by a run of <code>COUNT[0]</code> symbols 0, followed by a run of <code>COUNT[1]</code> symbols 1, etc.</p>
<p>Using the <code>COUNT</code> array, we compute the position <code>SORTEDPOS[0..255]</code> of each run of symbol in this array.</p>
<p>To perform the inverse Burrows–Wheeler transform, it is now sufficient to follow the thread backwards:</p>
<pre>
<!-- TODO -->
</pre>
The array <code>DATA[0..BLOCKSIZE - 2]</code> then contains the decoded bytes of the block.
</section><!-- 13.2.2.4 -->
</section><!-- 13.2.2 -->
</section><!-- 13.2 -->
</section><!-- 13 -->

</body>
</html>
