<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>DjVu Reference</title>
<style>
#about { margin: 0 auto; max-width: 65%; border: 1px solid black; font-size: larger; padding: 1rem; background-color: pink; }
a.bare, .filename { font-family: sans-serif; }
.hex, .ck { font-family: monospace; }
</style>
</head>
<body>
<div id="about">
This is a transcription, with minor orthographic and stylistic changes, of the official <a href="http://djvu.org/docs/DjVu3Spec.djvu">Celartem/Lizardtech DjVu Reference, version 3</a>.
</div>

<h1>DjVu Reference</h1>

<section id="1">
<h2>1 Introduction</h2>
<p>Althouh the Internet has given us a worldwide infrastructure on which to build the universal library, much of the world’s knowledge, history, and literature is still trapped on paper in the basements of the world’s traditional libraries. Many libraries and content owners are in the process of digitizing their collections. While many such efforts involve the painstaking process of converting paper documents to computer-friendly form, such as SGML-based formats, the high cost of such conversions limits their extent. Scanning documents and distributing the resulting images electronically is not only considerably cheaper, but also more faithful to the original document because it preserves its visual aspect.</p>
<!-- TODO -->
</section><!-- 1 -->

<section id="2">
<h2>2 Document organization</h2>
<p>This document describes the DjVu file format. It is written “from top down”, providing first a high-level understand ing of the features and techniques used in DjVu (see §<a href="#3">3</a>) , then a mid-level view at the IFF85 level (see §<a href="#7">7</a>), and finally a very detailed decription of the underlying algorithms and and byte-by-byte makeup of DjVu files (see §<a href="#8">8</a>).</p>
</section><!-- 2 -->

<section id="3">
<h2>3 Overview</h2>
<p>This section describes the DjVu file format at a high level: how DjVu uses the Mixed Raster Content model, how images are composed into documents, and the non-raster data that such documents can also contain.

<section id="3.1">
<h3>3.1 DjVu images</h3>
<p>The principal imaging model used in DjVu is the “Mixed Raster Content” (MRC) model described in ITU-T Recommendation T.44, ISO/IEC 16485. In this model, an image is decomposed into foreground and background layers. To select whether a particular pixel comes from the foreground or background, a bitonal “selection” or “mask” layer is provided. These three layers are compressed separately using techniques which are optimized for each type of data.</p>
<p>The foreground and background layers are compressed using a wavelete-based continous-tone image compression technique known as IW44.</p>
<p>The mask layer is compressed using a bitonal image compression technique that takes advantage of repetitions of nearly identical shapes on the page (such as characters) to efficiently compress text images.</p>
<p>A DjVu image need not contain all three layers and alternative compression techniques are available for each layer.</p>
</section><!-- 3.1 -->

<section id="3.2">
<h3>3.2 DjVu documents</h3>
<p>DjVu documents can be single- or multi-page. Each page consists of a DjVu image as described above (photo, bitonal, or an MRC-based composition). Such a page, by itself, is a valid DjVu document. Multi-page documents can take either of two forms: bundled or indirect.</p>

<section id="3.2.1">
<h4>3.2.1 Bundled multi-page documents</h4>
<p>A bundled multi-page DjVu document uses a single file to represent the entire document. This single file contains all the pages as well as ancillary information (e.g.&nbsp;the page directory, data shared by several pages, thumbnails, etc.). Using a single-file format is very convenient for storing documents or for sending email attachments.</p>
</section><!-- 3.2.1 -->

<section id="3.2.2">
<h4>3.2.2 Indirect multi-page documents</h4>
<p>There are problems inherent to storing multiple pages in a single file. A viewer may not be able to utilize a byte-serving mechanism such as that available in HTTP/1.1. Therefore any request for any page of such a file will necessarily result in the entire document being transmitted. Furthermore, a reasonable work pattern is to read the first few pages (perhaps a table of contents) and then navigate to a page much further into the document. However, in such a file, data for page 100 can not be viewed until after data for pages 1–99 have been downloaded.</p>
<p>Indirect multi-page documents address these problems. Such a document is composed of several files. The main file is named the index file. You can view document using the URL of the index file, just like you do with a bundled multi-page document. However, the index file is very small. It simply contains the document directory and the URLs of secondary files containing the page data. When you view an indirect multi-page document, the viewer only needs to download the files corresponding to the pages you are viewing.</p>
</section><!-- 3.2.2 -->

</section><!-- 3.2 -->

<section id="3.3">
<h3>3.3 Non-raster data</h3>

<section id="3.3.1">
<h4>3.3.1 Annotations</h4>
<p>Every DjVu image optionally includes several different kinds of annotations. These annotations are often used to define hyperlinks to other documentpages or to arbitrary web pages. They can also be used for other purposes such as setting the initial viewing mode of a page and defining highlighted zones.</p>
</section><!-- 3.3.1 -->

<section id="3.3.2">
<h4>3.3.2 Hidden text</h4>
<p>Every DjVu image optionally includes a hidden text layer that associates graphical features with the corresponding text. The hidden text layer is usually generated by running optical character recognition software. This textual information provides for indexing DjVu documents and copying/pasting text from DjVu page images.</p>
</section><!-- 3.3.2 -->

<section id="3.3.3">
<h4>3.3.3 Thumbnails</h4>
<p>DjVu documents sometimes contain pre-computed page thumbnails. These allow a viewer to display a graphical representation of many pages by downloading a very small “thumbnail” file instead of the actual pages themselves.</p>
</section><!-- 3.3.3 -->

</section><!-- 3.3 -->

</section><!-- 3 -->

<section id="4">
<h2>4 What’s new in the DjVu file format</h2>
</section><!-- 4 -->

<section id="5">
<h2>5 Acknowledgements</h2>
<p>This work is significantly based on Reference 1 and the summary of file format changes described in the DjVuLibre project maintained by Leon Bottou and others.</p>
</section><!-- 5 -->

<section id="6">
<h2>6 References</h2>

<section id="6.1">
<h3>6.1 DjVu 2</h3>
<p>The DjVu file format specification that was originally released by AT&amp;T in 1999. <a class="bare" href="http://djvuzone.org/djvu/djvu/djvuspec/001.djvu">http://djvuzone.org/djvu/djvu/djvuspec/001.djvu</a></p>
</section><!-- 6.1 -->

<section id="6.2">
<h3>6.2 IFF</h3>
<p>EA IFF 85 format, Electronic Arts’ public-domain IFF standard for an Interchange File Format, released in January, 1985. <a class="bare" href="http://www.dcs.ed.ac.uk/home/mxr/gfx/2d/IFF.txt">http://www.dcs.ed.ac.uk/home/mxr/gfx/2d/IFF.txt</a></p>
</section><!-- 6.2 -->

<section id="6.3">
<h3>6.3 JPEG</h3>
<p>JPEG File Interchange Format, Version 1.01 (ISO DIS 10918-1, JPEG JFIF). The specification is located at <a class="bare" href="http://www.w3.org/Graphics/JPEG/jfif.txt">http://www.w3.org/Graphics/JPEG/jfif.txt</a>.</p>
</section><!-- 6.3 -->

<section id="6.4">
<h3>6.4 TIFF</h3>
<p><a class="bare" href="http://partners.adobe.com/public/developer/en/tiff/TIFF6.pdf">http://partners.adobe.com/public/developer/en/tiff/TIFF6.pdf</a></p>
</section><!-- 6.4 -->

<section id="6.5">
<h3>6.5 G4</h3>
<p>ITU-T (CCITT) T.6. Facsimile Coding Schemes and Coding Control Functions for Group 4 Facsimile Apparatus</p>
</section><!-- 6.5 -->

<section id="6.6">
<h3>6.6 UTF-8</h3>
<p>All text in DjVu files is Unicode-encoded using the UTF-8 encoding. <a class="bare" href="http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf">http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf</a></p>
</section><!-- 6.6 -->

<section id="6.7">
<h3>6.7 DjVuLibre</h3>
<p>An open-source reference implementation of this file format specification is available at <a class="bare" href="http://sourceforge.net/projects/djvu/">http://sourceforge.net/projects/djvu/</a>. Throughout this specification, there are numerous references to source files in this implementation.</p>
</section><!-- 6.7 -->

</section><!-- 6 -->

<section id="7">
<h2>7 Component pieces (IFF chunks) of DjVu documents and images</h2>
</section><!-- 7 -->

<section id="8">
<h2>8 Low-level chunk structure and definition</h2>
<p>This section describes the DjVu file format at a low level. This includes the binary layout of the IFF85 wrapper and, of course, the layout of each contained chunk.</p>

<section id="8.1">
<h3>8.1 Header</h3>
<p>The first four bytes of a DjVu file are <span class="hex">0x41 0x54 0x26 0x54</span>. This preamble is not part of the EA IFF85 format, but it is required in order to identify DjVu files.</p>
</section><!-- 8.1 -->

<section id="8.2">
<h3>8.2 DjVu file structure</h3>

<section id="8.2.1">
<h4>8.2.1 IFF wrapper</h4>
<p>An IFF file consists of a number of chunks. Each chunk is laid out in three fields:</p>
<table>
<tr>
  <td><code>BYTE[4]</code></td>
  <td>Chunk ID. Describes the use of the chunk. The strings that identify the types of chunks used in DjVu are listed below.</td>
</tr>
<tr>
  <td><code>BE32</code></td>
  <td>The length of the data.</td>
</tr>
<tr>
  <td><code>BYTE[]</code></td>
  <td>The contained data.</td>
</tr>
</table>
<p>A chunk whose type is not recognized by the application is to be ignored. In the IFF format, chunks may be nested: a chunk may contain other chunks as part of its data. In the DjVu format, there is only one chunk at the outermost nesting level, a <span class="ck">FORM</span> chunk. All other chunks appear within the <span class="ck">FORM</span> chunk, sequentially, with no nesting.</p>
<p>Example:</p>
<table>
<tr>
  <td><span class="hex">00000000</span></td>
  <td><span class="hex">41 54 26 54</span></td>
  <td>"AT&amp;T"; magic described in §<a href="#8.1">8.1</a>.</td>
</tr>
<tr>
  <td><span class="hex">00000004</span></td>
  <td><span class="hex">46 4f 52 4d</span></td>
  <td>"FORM"; chunk ID = <span class="ck">FORM</span></td>
</tr>
<tr>
  <td><span class="hex">00000008</span></td>
  <td><span class="hex">00 00 68 a6</span></td>
  <td><span class="hex">0xa668</span> = 26970; length of this <span class="ck">FORM</span> chunk</td>
</tr>
<tr>
  <td><span class="hex">0000000b</span></td>
  <td><span class="hex">44 4a 56 55</span></td>
  <td>"DJVU"; first four bytes of contained data. Since this is a <span class="ck">FORM</span> chunk, this starts with the subidentifier. This is a <span class="ck">FORM:DJVU</span> chunk, a single-page document.</td>
</tr>
</table>
</section><!-- 8.2.1 -->

<section id="8.2.2">
<h4>8.2.2 Chunk summary</h4>
<p>The chunks used in the DjVu file format are summarized in Table 1.</p>
<table id="table-1">
<caption>Table 1: chunk summary</caption>
<thead>
<tr>
  <td>Chunk ID</td>
  <td>Usage</td>
</tr>
</thead>
<tbody>
<tr>
  <td><span class="ck">FORM</span></td>
  <td>The composite chunk. The first four bytes of the <span class="ck">FORM</span> chunk are a secondary identifier. Such chunks are referred to as <code>FORM:XXXX</code> where "<code>XXXX</code>" stands for the secondary identifier.</td>
</tr>
<tr>
  <td><span class="ck">FORM:DJVM</span></td>
  <td>A multi-page DjVu document. Composite chunk that contains the <span class="ck">DIRM</span> chunk, possible shared/included chunks and subsequent <span class="ck">FORM:DJVU</span> chunks which make up a multi-page document.</td>
</tr>
<tr>
  <td><span class="ck">FORM:DJVU</span></td>
  <td>A DjVu page/single-page DjVu document. Composite chunk that contains the chunks that make up a page in a DjVu document.</td>
</tr>
<tr>
  <td><span class="ck">FORM:DJVI</span></td>
  <td>A “shared” DjVu file which is included via the <span class="ck">INCL</span> chunk. Shared annotations, shared shape dictionary.</td>
</tr>
<tr>
  <td><span class="ck">FORM:THUM</span></td>
  <td>Composite chunk that contains the <span class="ck">TH44</span> chunks that are the embedded thumbnails.</td>
</tr>
<tr>
  <td><span class="ck">DIRM</span></td>
  <td>Page name information for multi-page documents.</td>
</tr>
<tr>
  <td><span class="ck">NAVM</span></td>
  <td>Bookmark information.</td>
</tr>
<tr>
  <td><span class="ck">ANTa</span>, <span class="ck">ANTz</span></td>
  <td>Annotations, including both initial view settings and overlaid hyperlinks, text boxes, etc.</td>
</tr>
<tr>
  <td><span class="ck">TXTa</span>, <span class="ck">TXTz</span></td>
  <td>Unicode text and layout information.</td>
</tr>
<tr>
  <td><span class="ck">Djbz</span></td>
  <td>Shared shape table.</td>
</tr>
<tr>
  <td><span class="ck">Sjbz</span></td>
  <td>BZZ-compressed JB2 bitonal data used to store mask.</td>
</tr>
<tr>
  <td><span class="ck">FG44</span></td>
  <td>IW44 data used to store foreground.</td>
</tr>
<tr>
  <td><span class="ck">BG44</span></td>
  <td>IW44 data used to store background.</td>
</tr>
<tr>
  <td><span class="ck">TH44</span></td>
  <td>IW44 data used to store embedded thumbnail images.</td>
</tr>
<tr>
  <td><span class="ck">WMRM</span></td>
  <td>JB2 data required to remove a watermark.</td>
</tr>
<tr>
  <td><span class="ck">FGbz</span></td>
  <td>Color JB2 data. Provides a color for each [blit or shape?] in the corresponding <span class="ck">Sjbz</span> chunk.</td>
</tr>
<tr>
  <td><span class="ck">INFO</span></td>
  <td>Information about a DjVu page.</td>
</tr>
<tr>
  <td><span class="ck">INCL</span></td>
  <td>The ID of an included <span class="ck">FORM:DJVI</span> chunk.</td>
</tr>
<tr>
  <td><span class="ck">BGjp</span></td>
  <td>JPEG-encoded background.</td>
</tr>
<tr>
  <td><span class="ck">FGjp</span></td>
  <td>JPEG-encoded foreground.</td>
</tr>
<tr>
  <td><span class="ck">Smmr</span></td>
  <td>G4-encoded mask.</td>
</tr>
</tbody>
</table>
</section><!-- 8.2.2 -->

</section><!-- 8.2 -->

<section id="8.3">
<h3>8.3 IFF chunk types</h3>

<section id="8.3.1">
<h4>8.3.1 Container chunk: <span class="ck">FORM</span></h4>
<p>The <span class="ck">FORM</span> chunk is used as a chunk container. The first four bytes of the <span class="ck">FORM</span> chunk are a secondary ID used to identify the contained chunks.</p>

<section id="8.3.1.1">
<h5>8.3.1.1 <span class="ck">FORM:DJVM</span></h5>
<p>As discussed in §<a href="#7.2">7.2</a>, a multi-page DjVu document is composed of a single (composite) <span class="ck">FORM:DJVM</span> chunk. The first nested chunk is always a <span class="ck">DIRM</span> chunk containing the document directory (see <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/DjVmDir.cpp">DjVmDir.h</a>), which represents the list of the component files that make up the document. An optional <span class="ck">NAVM</span> chunk, which describes the outline of the document, may follow the <span class="ck">DIRM</span> chunk.</p>
<p>Example:</p>
<pre>
<span class="ck">FORM:DJVM</span> [126475 bytes]
  <span class="ck">DIRM</span> [59 bytes] Document directory (bundled, 3 files, 2 pages)
  <span class="ck">FORM:DJVI</span> [3493 bytes] <span class="filename">dict0002.iff</span>
  <span class="ck">FORM:DJVU</span> [115016 bytes] <span class="filename">p0001.djvu</span>
  <span class="ck">FORM:DJVU</span> [7869 bytes] <span class="filename">p0002.djvu</span>
</pre>
</section><!-- 8.3.1.1 -->

<section id="8.3.1.2">
<h5>8.3.1.2 <span class="ck">FORM:DJVU</span></h5>
<p>As discussed in §<a href="7.1">7.1</a>, a single page in a DjVu document is contained in a single (composite) <span class="ck">FORM:DJVU</span> chunk. The nested first chunk must be the <span class="ck">INFO</span> chunk. The chunks after the <span class="ck">INFO</span> chunk may occur in any order, although the order of the <span class="ck">BG44</span> chunks, if there is more than one, is significant.</p>
<p>Example:</p>
<pre>
<span class="ck">FORM:DJVU</span> [26790 bytes]
  <span class="ck">INFO</span> [10 bytes] 2202 × 967, version 26, 300 dpi, gamma = 2.2
  <span class="ck">Sjbz</span> [13133 bytes] JB2 bilevel data
  <span class="ck">FG44</span> [185 bytes] IW44 data #1, 76 slices, version 1.2 (color), 184 × 81
  <span class="ck">BG44</span> [935 bytes] IW44 data #1, 74 slices, version 1.2 (color), 734 × 323
  <span class="ck">BG44</span> [1672 bytes] IW44 data #2, 10 slices
  <span class="ck">BG44</span> [815 bytes] IW44 data #3, 4 slices
  <span class="ck">BG44</span> [9976 bytes] IW44 data #4, 9 slices
</pre>
</section><!-- 8.3.1.2 -->

<section id="8.3.1.3">
<h5>8.3.1.3 <span class="ck">FORM:DJVI</span></h5>
<p>Multi-page DjVu documents can share information between pages by nesting a chunk inside a <span class="ck">FORM:DJVI</span> chunk (which is itself held inside the <span class="ck">FORM:DJVM</span> chunk) and referencing the contained chunk from within a page. Individual pages reference the shared chunks via the <span class="ck">INCL</span> chunk.</p>
<p>Example:</p>
<pre>
<span class="ck">FORM:DJVM</span> [126475 bytes]
  <span class="ck">DIRM</span> [59 bytes] Document directory (bundled, 3 files, 2 pages)
  <strong><span class="ck">FORM:DJVI</span> [3493 bytes] <span class="filename">dict0002.iff</span></strong>
    <strong><span class="ck">Djbz</span> [3481 bytes] JB2 shared dictionary</strong>
  <span class="ck">FORM:DJVU</span> [115016 bytes] <span class="filename">p0001.djvu</span>
    <span class="ck">INFO</span> [10 bytes] 2539 × 3295, version 25, 300 dpi, gamma = 2.2
    <strong><span class="ck">INCL</span> [12 bytes] Indirection chunk → <span class="filename">dict0002.iff</span></strong>
    <span class="ck">Sjbz</span> [70497 bytes] JB2 bilevel data
</pre>
</section><!-- 8.3.1.3 -->

<section id="8.3.1.4">
<h5>8.3.1.4 <span class="ck">FORM:THUM</span></h5>
<p>Pre-rendered thumbnails may be included. This allows very large documents to render thumbnails of pages without downloading and decoding them. <span class="ck">FORM:THUM</span> chunks contain several <span class="ck">TH44</span> chunks. Each of these chunks contains the thumbnails of the pages that follow.</p>
<p>Example:</p>
<pre>
<!-- TODO -->
</pre>
</section><!-- 8.3.1.4 -->

</section><!-- 8.3.1 -->

<section id="8.3.2">
<h4>8.3.2 Directory chunk: <span class="ck">DIRM</span></h4>
<p></p>
</section><!-- 8.3.2 -->

</section><!-- 8.3 -->

</section><!-- 8 -->

<section id="9">
<h2>9 DjVu in the raw (binary and IFF-level dumps)</h2>
</section><!-- 9 -->

<section id="10">
<h2>10 Appendix 1: IW44 coding</h2>
</section><!-- 10 -->

<section id="11">
<h2>11 Appendix 2: JB2 coding</h2>
</section><!-- 11 -->

<section id="12">
<h2>12 Appendix 3: Z&prime; coding</h2>
<p>The Z&prime;-Coder is an approximate binary arithmetic coder. Decoding proceeds as follows.</p>
<p>See also files <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/ZPCodec.h">ZPCodec.h</a> and <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/ZPCodec.cpp">ZPCodec.cpp</a> in DjVuLibre.</p>

<section id="12.1">
<h3>12.1 Registers and data storage</h3>
<p>In Figure 1 and Figure 2, the values of variables <var>A</var>, <var>C</var>, <var>D</var>, and <var>Z</var> are stored in registers of at least 16 bits each. <var>A</var> and <var>C</var> retain their values between invocations of the Z&prime;-Coder.</p>
<aside>
<p>Note: if register overflow can be ignored, storing variables <var>A</var> and <var>C</var> in registers of exactly 16 bits allows a simplification of lines 11, 12, 16, and 17 of Figure 1 and lines 8, 9, 12, and 13 of Figure 2.</p>
</aside>
<p>At the beginning of a chunk, the values of <var>A</var> and <var>C</var> are reinitialized. When the decoder is decoding a chunk, it may require more bits than are present within the chunk’s data. In this case, all additional required bits are to be assumed by the decoder to be 1. If there are excess bits at the end of a chunk, they are ignored.</p>
</section><!-- 12.1 -->

</section><!-- 12 -->

<section id="13">
<h2>13 Appendix 4: BZZ coding</h2>
<p>Numerous streams in the DjVu file format are compressed using the general-purpose compressor described here called “BZZ”. BZZ transforms the input data using the well-documented Burrows–Wheeler transform. However, the traditional “Move To Front” permutation table is augmented with a frequency estimation provided by the Z&prime;-Coder.</p>
<p>See also file <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/BSByteStream.cpp">BSByteStream.cpp</a>.</p>

<section id="13.1">
<h3>13.1 Encoding</h3>
<p>BZZ first takes as input a 24-bit integer as block size between 10K and 4M and an input stream (to be compressed). The stream is partitioned into blocks terminated with a special <code>&langle;EOB&rangle;</code> symbol. It is then transformed using the well-documented Burrows–Wheeler (BW or “block sorting”) transform. Then, one block at a time, the block size and resulting output stream are passed as input to be compressed using the Z&prime;-Coder (<a href="#12">Appendix 3</a>).</p>
</section><!-- 13.1 -->

<section id="13.2">
<h3>13.2 Decoding</h3>
<p>We describe the decoding algorithm by means of pseudo-code.</p>

<section id="13.2.1">
<h4>13.2.1 Decoding pseudo-code</h4>
<!-- TODO -->
</section><!-- 13.2.1 -->

<section id="13.2.2">
<h4>13.2.2 Notes</h4>

<section id="13.2.2.1">
<h5>13.2.2.1 Overview of decoding a block</h5>
<p>For each block, one must decode</p>
<ul>
<li>the block size (with <code>decode_raw</code>)</li>
<li>the estimation speed <code>FSHIFT ∈ {0, 1, 2}</code> (two bits with the passthrough decoder)</li>
<li>the sequence of symbols representing the Burrows–Wheeler transform of the block. At this point, the sequence of symbols is logically encoded as a sequence of numbers representing the position of each symbol in the MTF array.</li>
</ul>
<p>Then one must perform the inverse Burrows–Wheeler transform to recover the decoded block.</p>
<p>The following points are significant when recovering the BWT and are discussed below:</p>
<ul>
<li>The MTF array is reordered after decoding each number.</li>
<li>The numbers themselves are arithmetically encoded.</li>
</ul>
</section><!-- 13.2.2.1 -->

<section id="13.2.2.2">
<h5>13.2.2.2 MTF array reordering</h5>
<p>The MTF array contains 256 bytes initialized with the identity mapping, that is <code>MTF[0] = 0</code>, <code>MTF[1] = 1</code>, … , <code>MTF[255] = 255</code>.</p>
<p>Whenever one decodes a number <code>MTFNO</code>, the corresponding symbol to store in the Burrows–Wheeler buffer is <code>MTF[MTFNO]</code> (except for the <code>&langle;EOB&rangle;</code> symbol — see §<a href="#13.2.2.3">13.2.2.3</a>) and the contents of the MTF array are rotated. The rotation moves the symbol that was at position <code>MTF[MTFNO]</code> to a position <code>M</code> that can be 0, 1, 2, or 3. Meanwhile the symbols <code>MTF[M]</code> to <code>MTF[MTFNO - 1]</code> are moved to positions <code>M + 1</code> to <code>MTFNO</code>.</p>
<p>The position <code>M</code> is chosen using an estimate of the frequency of the symbol <code>MTF[MTFNO]</code>. One strives to position the most frequent symbols at the beginning of the MTF array. To that end, one maintains an array <code>FREQ[0..3]</code> that contains numbers representative of the instantaneous frequencies of the symbols <code>MTF[0..3]</code>.</p>
<p>Of course this array must also be “rotated” when the rotation of the MTF array affects its first four elements.</p>
<p>Consider the frequency
<math>
  <mi>F</mi>
  <mo stretchy="false" form="prefix">(</mo>
  <mi>T</mi>
  <mo stretchy="false" form="postfix">)</mo>
</math>
of a particular symbol
<math>
  <mi>S</mi>
</math>
measured after decoding the
<math>
<mi>T</mi>
</math>th
symbol. Ideally,
<math display="block">
  <mrow>
    <mi>F</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>=</mo>
    <mi>λ</mi>
    <mi>F</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo>−</mo>
    <mn>1</mn>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>+</mo>
    <mi>D</mi>
  </mrow>
</math>
where</p>
<ul>
<li>
<math>
  <mrow>
    <mn>0</mn>
    <mo>&lt;</mo>
    <mi>λ</mi>
    <mo>≤</mo>
    <mn>1</mn>
  </mrow>
</math>.
This models how quickly one forgets past information, and
</li>
<li>
<math>
  <mrow>
    <mi>D</mi>
    <mo>=</mo>
    <mn>1</mn>
  </mrow>
</math>
if the <math><mi>T</mi></math>th symbol is <math><mi>S</mi></math>, and
<math>
  <mrow>
    <mi>D</mi>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
</math>
otherwise. This allows
<math>
  <mi>F</mi>
  <mo stretchy="false" form="prefix">(</mo>
  <mi>T</mi>
  <mo stretchy="false" form="postfix">)</mo>
</math>
to grow each time the symbol <math><mi>S</mi></math> occurs.
</li>
</ul>
<p>To avoid multiplying all the frequencies by <math><mi>λ</mi></math>, the <code>FREQ</code> array contains instead
<math display="block">
  <mrow>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>=</mo>
    <mi>F</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo stretchy="false" form="postfix">)</mo>
    <mi>/</mi>
    <msup>
      <mi>λ</mi>
      <mi>T</mi>
    </msup>
  </mrow>
</math>
It is then easy to see that
<math display="block">
  <mrow>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>=</mo>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo>−</mo>
    <mn>1</mn>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>+</mo>
    <mi>D</mi>
    <mi>/</mi>
    <msup>
      <mi>λ</mi>
      <mi>T</mi>
    </msup>
  </mrow>
</math>
Therefore we only need to update the <math><mi>G</mi></math> corresponding to the symbol being decoded (i.e.&nbsp;<math>
  <mrow>
    <mi>D</mi>
    <mo>=</mo>
    <mn>1</mn>
  </mrow>
</math>),
since the <math><mi>G</mi></math> for the other symbols does not change.</p>
<p>A dedicated variable <code>FADD</code> contains
<math>
  <mrow>
    <msup>
      <mi>λ</mi>
      <mi>T</mi>
    </msup>
  </mrow>
</math>.
Before each rotation we divide <code>FADD</code> by 
<math>
  <mrow>
    <msup>
      <mi>λ</mi>
      <mi>T</mi>
    </msup>
  </mrow>
</math>.
This is accomplished by the line
<pre>
<code>FADD = FADD + SHIFTRIGHT(FADD, FSHIFT)</code>
</pre>
<p>The values 0, 1 or 2 of variable <code>FSHIFT</code> correspond to
<math>
  <mrow>
    <mi>λ</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mi>/</mi>
    <mn>2</mn>
  </mrow>
</math>,
<math><mn>2</mn><mi>/</mi><mn>3</mn></math>, or
<math><mn>4</mn><mi>/</mi><mn>5</mn></math>.
To avoid overflows we divide everything (<code>FADD</code> and <code>FREQ[0..3]</code>) by <code>0x10000000</code> whenever <code>FADD</code> becomes bigger than <code>0x10000000</code>. This happens rarely enough to take very little time.</p>
<p>The
<math>
  <mi>G</mi>
  <mo stretchy="false" form="prefix">(</mo>
  <mi>T</mi>
  <mo stretchy="false" form="postfix">)</mo>
</math>
of the freshly decoded symbol is therefore
<math>
  <mrow>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo>−</mo>
    <mn>1</mn>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>+</mo>
  </mrow>
</math><code>FADD</code>.
We can only compute this exactly when <math><mi>S</mi></math> is one of the first four symbols of the MTF because we only store <code>FREQ[0..3]</code>. If the decoded number <code>MTFNO</code> is greater than 3, we assume that 
<math>
  <mrow>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo>−</mo>
    <mn>1</mn>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
</math>
and simply consider 
<math>
  <mrow>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>=</mo>
  </mrow>
</math><code>FADD</code>.</p>
<p>The number <code>M</code> is then chosen to make sure the array <code>FREQ</code> remains sorted in decreasing order after the rotation.</p>
</section><!-- 13.2.2.2 -->

<section id="13.2.2.3">
<h5>13.2.2.3 Decoding the number <code>MTFNO</code></h5>
<p>Now we can discuss how the numbers <code>MTFNO</code> are stored. There are 262 arithmetic coding contexts. These are initialized to zero at the beginning of the stream decoding process. They should <em>not</em> be reset to zero at the beginning of the block decoding process.</p>
<p>Because the most frequently used symbols should appear near the front of the array, we expect small values for <code>MTFNO</code> (the index into the MTF array). By design, the number of bits and the number of contexts required to decode increases for larger values of <code>MTFNO</code>:</p>
<ul>
<li>A first bit is decoded using context 0, 1 or 2.</li>
<li>Context 0 or 1 is used if the previous <code>MTFNO</code> was 0 or 1. Otherwise context 2 is used. If this bit is set, the new <code>MTFNO</code> is 0.</li>
<li>Otherwise a second bit is decoded using context 3, 4 or 5. Context 3 or 4 is used if the previous <code>MTFNO</code> was 0 or 1. Otherwise context 5 is used. If this bit is set, the new <code>MTFNO</code> is 1.</li>
<li>Otherwise a third bit is decoded using context 6. If this bit is set, the new <code>MTFNO</code> is obtained by adding 2 to a 1-bit number decoded with <code>decode_bin</code> using context 7.</li>
<li>Otherwise a fourth bit is decoded using context 8. If this bit is set, the new <code>MTFNO</code> is obtained by adding 4 to a 2-bit number decoded with <code>decode_bin</code> using contexts <code>9..11</code>.</li>
<li>And so forth until…</li>
<li>Otherwise a ninth bit is decoded using context 132. If this bit is set, the new <code>MTFNO</code> is obtained by adding 128 to a 7-bit number decoded with <code>decode_bin</code> using contexts <code>133..261</code>.</li>
<li>Otherwise the next symbol is the <code>&langle;EOB&rangle;</code> symbol. Since there is only one <code>&langle;EOB&rangle;</code> symbol, we store a zero in the Burrows–Wheeler buffer and record its position in variable <code>MARKERPOS</code>.</li>
</ul>
</section><!-- 13.2.2.3 -->

<section id="13.2.2.4">
<h5>13.2.2.4 Inverse Burrows–Wheeler transform</h5>
<p>After decoding the <code>BLOCKSIZE</code> symbols composing the Burrows–Wheeler buffer, we need to perform the inverse Burrows–Wheeler transform to recover the <code>BLOCKSIZE - 1</code> decoded bytes followed by the <code>&langle;EOB&rangle;</code> symbol.</p>
<p>To start, we</p>
<ul>
<li>copy the buffer into an array <code>POSC[0..BLOCKSIZE - 1]</code>,</li>
<li>prepare an array <code>COUNT[0..255]</code> that counts how many occurrences of each symbol are found,</li>
<li>prepare an array <code>POSN[0..BLOCKSIZE - 1]</code> that indicates the rank of each occurrence of a symbol in the buffer.</li>
</ul>
<p>Imagine that we are sorting the buffer in symbol order (<code>&langle;EOB&rangle;</code> being the smallest symbol). The buffer would be composed of a single <code>&langle;EOB&rangle;</code>, followed by a run of <code>COUNT[0]</code> symbols 0, followed by a run of <code>COUNT[1]</code> symbols 1, etc.</p>
<p>Using the <code>COUNT</code> array, we compute the position <code>SORTEDPOS[0..255]</code> of each run of symbol in this array.</p>
<p>To perform the inverse Burrows–Wheeler transform, it is now sufficient to follow the thread backwards:</p>
<pre>
<!-- TODO -->
</pre>
The array <code>DATA[0..BLOCKSIZE - 2]</code> then contains the decoded bytes of the block.
</section><!-- 13.2.2.4 -->
</section><!-- 13.2.2 -->
</section><!-- 13.2 -->
</section><!-- 13 -->

</body>
</html>
